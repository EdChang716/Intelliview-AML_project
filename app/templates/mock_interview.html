<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mock Interview â€“ Intelliview Coach</title>

  <!-- Global nav -->
  <link rel="stylesheet" href="/static/global-nav.css?v=11" />
  <!-- This page CSS -->
  <link rel="stylesheet" href="/static/mock_interviews.css?v=11" />
</head>

<body>
  <div class="app-container">

    <!-- Top nav -->
    <header class="top-nav">
      <div class="nav-left">
        <div class="logo-dot"></div>
        <span class="logo-text">Intelliview&nbsp;Coach</span>
      </div>
      <nav class="nav-links">
        <a href="/">Home</a>
        <a href="{{ request.url_for('resume_page') }}">Resume</a>
        <a href="{{ request.url_for('profiles_page') }}">Profiles</a>
        <a href="{{ request.url_for('mock_settings_page') }}" class="nav-active">Mock</a>
      </nav>
    </header>

    <main class="mock-main">
      <!-- é¡Œç›® Bannerï¼šæ•´é æœ€ä¸Šé¢ -->
      <section class="question-banner">
        <div class="question-banner-inner">
          <div class="question-banner-top">
            <span class="question-tag" id="question-tag">Mock interview</span>
            <!-- ä¹‹å¾Œå¦‚æœè¦æ”¾ Track / Warm-up éƒ½å¯ä»¥å¡åœ¨é€™è£¡ -->
            <span class="question-meta" id="question-meta"></span>
          </div>
          <div class="question-text" id="question-text">
            When youâ€™re ready, click <strong>Start interview</strong>.<br />
            Iâ€™ll ask you questions one by one and record your answer for each.
          </div>
        </div>
      </section>

      <!-- ä¸‹æ–¹ï¼šå·¦å´éŒ„å½±å¡ç‰‡ + å³å´ hints -->
      <section class="mock-layout">
        <!-- å·¦é‚Šï¼šéŒ„å½±å€ -->
        <section class="interview-container">
          <div class="video-shell">
            <div class="video-box">
              <!-- éŒ„å½±ç‹€æ…‹ pill -->
              <div id="recording-pill" class="recording-pill recording-preview">
                <span class="rec-dot"></span>
                <span class="rec-text">Camera preview</span>
              </div>
              <video id="preview" autoplay muted playsinline></video>
            </div>

            <!-- æ§åˆ¶æŒ‰éˆ•åˆ— -->
            <div class="controls">
              <button id="start-btn" class="btn start-btn">Start interview</button>
              <button id="next-btn" class="btn next-btn" disabled>Next question</button>
              <button id="end-btn" class="btn end-btn" disabled>End interview</button>
            </div>

            <!-- Timer + ç‹€æ…‹åˆ— -->
            <div class="status-row">
              <div class="timer-row" id="timer-row" style="display: none;">
                <span class="timer-label">Time remaining</span>
                <span class="timer-value" id="timer-value">--:--</span>
              </div>
              <p class="status-text" id="mock-status"></p>
            </div>

            <!-- REALTIME: debug å€å¡Šé¡¯ç¤ºå³æ™‚ transcript -->
            <div class="status-row">
              <span class="timer-label">Realtime transcript</span>
              <span class="status-text" id="realtime-transcript"></span>
            </div>
          </div>
        </section>

        <!-- å³é‚Šï¼šCoaching hints - Redesigned with collapsible sections -->
        <aside class="hints-panel" id="hints-panel">
          <h3>ğŸ’¡ Coaching Hints</h3>
          <div id="hints-container">
            <p class="hint-empty">
              Once the interview starts, you'll see helpful tips here.
            </p>
          </div>
        </aside>
      </section>
    </main>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", async () => {
      // å¾å¾Œç«¯ä¾†çš„ session è¨­å®š
      const SESSION_CONFIG = JSON.parse('{{ session_config_json | safe }}');
      const hintLevel    = SESSION_CONFIG.hint_level || "standard";
      const lengthType   = SESSION_CONFIG.length_type || "questions"; // "questions" | "time"
      const timeLimitMin = SESSION_CONFIG.time_limit;                 // åˆ†é˜ï¼ˆå¯èƒ½ç‚º nullï¼‰

      // â­ å¾ session_config æ‹¿ interviewer profile
      const INTERVIEWER_PROFILE = SESSION_CONFIG.interviewer_profile || {};
      const INTERVIEWER_GENDER =
        INTERVIEWER_PROFILE.gender || "auto";

      // å„ªå…ˆç”¨ tts_personaï¼Œæ²’æœ‰çš„è©±ç”¨ role_resolved + style_resolved + extra_notes æ‹¼ä¸€ä¸²
      const INTERVIEWER_TTS_PERSONA =
        INTERVIEWER_PROFILE.tts_persona ||
        [
          INTERVIEWER_PROFILE.role_resolved,
          INTERVIEWER_PROFILE.style_resolved,
          INTERVIEWER_PROFILE.extra_notes,
        ].filter(Boolean).join(" ");

      const qTagEl       = document.getElementById("question-tag");
      const qTextEl      = document.getElementById("question-text");
      const hintsPanel   = document.getElementById("hints-panel");
      const hintsBox     = document.getElementById("hints-container");
      const statusEl     = document.getElementById("mock-status");
      const rtEl         = document.getElementById("realtime-transcript");

      const startBtn     = document.getElementById("start-btn");
      const nextBtn      = document.getElementById("next-btn");
      const endBtn       = document.getElementById("end-btn");
      const videoEl      = document.getElementById("preview");

      const timerRow     = document.getElementById("timer-row");
      const timerValue   = document.getElementById("timer-value");

      const recordingPill = document.getElementById("recording-pill");
      const recordingTextEl = recordingPill
        ? recordingPill.querySelector(".rec-text")
        : null;

      // Timer ç‹€æ…‹ï¼ˆåªåœ¨æ™‚é–“æ¨¡å¼æœƒç”¨åˆ°ï¼‰
      let remainingSeconds = null;
      let timerId = null;

      // ---------- Utility ----------
      function setStatus(msg) {
        if (statusEl) statusEl.textContent = msg || "";
      }

      function setRecordingPill(mode, label) {
        if (!recordingPill || !recordingTextEl) return;
        recordingPill.className = "recording-pill recording-" + mode;
        recordingTextEl.textContent = label;
      }

      function escapeHtml(str) {
        if (!str) return "";
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function formatTime(totalSec) {
        const m = Math.floor(totalSec / 60);
        const s = totalSec % 60;
        const mm = String(m).padStart(2, "0");
        const ss = String(s).padStart(2, "0");
        return `${mm}:${ss}`;
      }

      function startTimerIfNeeded() {
        // åªåœ¨ã€Œæ™‚é–“æ¨¡å¼ã€ä¸”æœ‰ time_limit æ™‚å•Ÿå‹•
        if (lengthType !== "time" || !timeLimitMin) return;
        if (!timerRow || !timerValue) return;

        remainingSeconds = timeLimitMin * 60;
        timerRow.style.display = "inline-flex";
        timerValue.textContent = formatTime(remainingSeconds);

        if (timerId) {
          window.clearInterval(timerId);
          timerId = null;
        }

        timerId = window.setInterval(() => {
          remainingSeconds -= 1;
          if (remainingSeconds < 0) remainingSeconds = 0;
          timerValue.textContent = formatTime(remainingSeconds);

          if (remainingSeconds === 0) {
            window.clearInterval(timerId);
            timerId = null;
            // ä¸å¼·åˆ¶åˆ‡æ‰ç›®å‰é€™é¡Œï¼Œåªæ˜¯ä¸å†å…è¨±æ›æ–° main é¡Œ
            setStatus("Time is up. Finish your current answer and click End interview.");
            nextBtn.disabled = true;
            startBtn.disabled = true;
          }
        }, 1000);
      }

      // ---------- TTSï¼šå•é¡Œè‡ªå‹•æ’­ ----------
      let currentTtsAudio = null;

      async function speakQuestion(text) {
        const clean = (text || "").trim();
        if (!clean) return;

        try {
          // å¦‚æœå‰ä¸€æ®µé‚„åœ¨æ’­ï¼Œå…ˆåœæ‰
          if (currentTtsAudio) {
            try {
              currentTtsAudio.pause();
            } catch (e) {}
            if (currentTtsAudio.src) {
              URL.revokeObjectURL(currentTtsAudio.src);
            }
            currentTtsAudio = null;
          }

          const resp = await fetch("/api/tts_question", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              text: clean,
              session_id: SESSION_CONFIG.session_id, 
            }),
          });

          if (!resp.ok) {
            console.error("TTS HTTP error:", resp.status, await resp.text());
            return;
          }

          const blob = await resp.blob();
          console.log("TTS blob size:", blob.size);

          const url = URL.createObjectURL(blob);
          const audio = new Audio(url);
          currentTtsAudio = audio;

          audio.onended = () => {
            if (audio.src) {
              URL.revokeObjectURL(audio.src);
            }
            if (currentTtsAudio === audio) {
              currentTtsAudio = null;
            }
          };

          audio.play().catch((e) => {
            console.warn("Audio play failed:", e);
          });
        } catch (e) {
          console.error("TTS fetch error:", e);
        }
      }

      // ---------- éŒ„å½± / éŸ³è¨Š / Realtime ç‹€æ…‹ ----------
      let mediaStream = null;
      let mediaRecorder = null;
      let recordingChunks = [];

      let currentQuestionIndex = -1;  // -1 = é‚„æ²’é–‹å§‹
      let currentQuestion = null;     // { question_id, question, tag, bullets, hints, ... }

      // REALTIME: audio + ws ç‹€æ…‹
      let audioCtx = null;
      let audioSource = null;
      let audioProcessor = null;
      let realtimeWS = null;
      let realtimeEnabled = true;

      // Realtime transcriptï¼šæ•´å ´ç´¯ç© + å–®é¡Œç´¯ç©
      const TARGET_SR = 24000;                 // OpenAI realtime transcription æœŸæœ› 24kHz
      let globalTranscriptSoFar = "";          // æ•´å ´åˆ°ç›®å‰ç‚ºæ­¢çš„å…¨æ–‡
      let currentRealtimeTranscript = "";      // ç›®å‰é€™ä¸€é¡Œçš„ transcriptï¼ˆæœƒä¸Šå‚³å¾Œç«¯ï¼‰

      function floatTo16BitPCM(float32Array) {
        const pcm16 = new Int16Array(float32Array.length);
        for (let i = 0; i < float32Array.length; i++) {
          let s = Math.max(-1, Math.min(1, float32Array[i]));
          pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
        }
        return pcm16;
      }

      function arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = "";
        for (let i = 0; i < bytes.byteLength; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      }

      // ç°¡å–®çš„ downsampleï¼šæŠŠ input (Float32) å¾åŸæœ¬ sampleRate å£“åˆ° targetSampleRate
      function resampleToTarget(input, inputSampleRate, targetSampleRate) {
        if (!input || input.length === 0) return input;
        if (!inputSampleRate || inputSampleRate === targetSampleRate) {
          return input;
        }

        const ratio = inputSampleRate / targetSampleRate;
        const newLength = Math.floor(input.length / ratio);
        const output = new Float32Array(newLength);

        for (let i = 0; i < newLength; i++) {
          const pos = i * ratio;
          const idx = Math.floor(pos);
          const frac = pos - idx;
          const v0 = input[idx] ?? 0;
          const v1 = input[idx + 1] ?? v0;
          output[i] = v0 + (v1 - v0) * frac;  // linear interpolation
        }
        return output;
      }

      // é€£ç·šåˆ°ä½ è‡ªå·±çš„ proxy WebSocket: ws://host/ws/mock_realtime
      function setupRealtimeWebSocket() {
        if (!realtimeEnabled) return;
        if (realtimeWS && realtimeWS.readyState === WebSocket.OPEN) return;

        const wsProtocol = window.location.protocol === "https:" ? "wss" : "ws";
        const wsUrl = `${wsProtocol}://${window.location.host}/ws/mock_realtime`;

        const ws = new WebSocket(wsUrl);
        realtimeWS = ws;

        ws.onopen = () => {
          console.log("Realtime proxy WS opened:", wsUrl);
        };

        ws.onmessage = (event) => {
          console.log("[Realtime WS message raw]:", event.data);
          try {
            const msg = JSON.parse(event.data);
            if (msg.type === "transcript" && typeof msg.text === "string") {
              const full = msg.text;

              // æ–°å¢çš„ç‰‡æ®µ = é€™æ¬¡å®Œæ•´å…§å®¹ - ä¸Šä¸€æ¬¡å®Œæ•´å…§å®¹
              const diff = full.slice(globalTranscriptSoFar.length);
              globalTranscriptSoFar = full;

              if (diff) {
                currentRealtimeTranscript += diff;
              }

              console.log("Realtime full transcript:", full);
              console.log("Current question transcript:", currentRealtimeTranscript);

              if (rtEl) rtEl.textContent = currentRealtimeTranscript;
            }
          } catch (e) {
            console.warn("Error parsing realtime WS message:", e);
          }
        };

        ws.onerror = (e) => {
          console.error("Realtime WS error:", e);
        };

        ws.onclose = () => {
          console.log("Realtime proxy WS closed");
        };
      }

      function setupAudioPipeline() {
        try {
          if (!mediaStream || !window.AudioContext) return;
          if (audioCtx) return; // å·²ç¶“è¨­å®šé

          const AC = window.AudioContext || window.webkitAudioContext;
          audioCtx = new AC();

          if (audioCtx.state === "suspended") {
            audioCtx.resume().catch((e) => {
              console.warn("AudioContext resume error:", e);
            });
          }

          audioSource = audioCtx.createMediaStreamSource(mediaStream);
          const bufferSize = 4096;
          audioProcessor = audioCtx.createScriptProcessor(bufferSize, 1, 1);

          audioSource.connect(audioProcessor);
          audioProcessor.connect(audioCtx.destination);

          audioProcessor.onaudioprocess = (event) => {
            if (!realtimeWS || realtimeWS.readyState !== WebSocket.OPEN) return;

            const input = event.inputBuffer.getChannelData(0); // Float32 (likely 48kHz)
            const inSampleRate = audioCtx.sampleRate || 48000;

            // ğŸ”¹ å…ˆ downsample åˆ° 24kHz
            const resampled = resampleToTarget(input, inSampleRate, TARGET_SR);

            // å†è½‰æˆ Int16 PCM
            const pcm16 = floatTo16BitPCM(resampled);
            const b64 = arrayBufferToBase64(pcm16.buffer);

            const msg = {
              type: "input_audio_buffer.append",
              audio: b64,
            };
            try {
              realtimeWS.send(JSON.stringify(msg));
            } catch (e) {
              console.warn("Failed to send audio chunk:", e);
            }
          };

          console.log("Audio pipeline set up for realtime transcription. sampleRate =", audioCtx.sampleRate);
        } catch (e) {
          console.error("setupAudioPipeline error:", e);
          realtimeEnabled = false;
        }
      }

      // åªé–‹ camera previewï¼Œä¸é–‹å§‹éŒ„å½±
      async function initCameraPreview() {
        try {
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            console.warn("getUserMedia not supported.");
            setStatus("Camera preview not supported in this browser.");
            setRecordingPill("error", "Camera unavailable");
            return;
          }
          mediaStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,   // è¦éŒ„éŸ³
          });
          videoEl.srcObject = mediaStream;
          setStatus("Camera is on. Click Start interview when youâ€™re ready.");
          setRecordingPill("preview", "Camera preview");

          setupRealtimeWebSocket();  // REALTIME: å…ˆé–‹å¾Œç«¯ proxy WS
          setupAudioPipeline();      // REALTIME: å†æŠŠéŸ³è¨Šä¸²ä¸Šå»
        } catch (err) {
          console.error("Failed to init camera:", err);
          setStatus("Failed to access camera / microphone.");
          setRecordingPill("error", "Camera blocked");
        }
      }

      await initCameraPreview();

      // ---------- Hints rendering - Redesigned with collapsible sections ----------
      function renderHints(hints, suggestedBullets) {
        // å®Œå…¨æ²’æœ‰ä»»ä½•æç¤ºå°±æŠŠ panel æ”¶æ‰
        if (
          (!hints || hints.show === false || hintLevel === "minimal") &&
          (!suggestedBullets || !suggestedBullets.length)
        ) {
          hintsPanel.style.display = "none";
          return;
        }
        hintsPanel.style.display = "block";

        const bullets   = (hints && hints.bullets) || [];
        const structure = (hints && hints.structure) || "";
        const extra     = (hints && hints.extra) || "";

        let html = "";
        let sectionCount = 0;

        // Helper function to create collapsible section
        const createCollapsibleSection = (id, title, content, defaultOpen = false) => {
          sectionCount++;
          const activeClass = defaultOpen ? ' active' : '';
          return `
            <div class="hint-collapsible">
              <button class="hint-toggle${activeClass}" onclick="toggleHintSection('${id}')">
                <span>${title}</span>
                <span class="hint-toggle-icon">â–¼</span>
              </button>
              <div class="hint-content${activeClass}" id="${id}">
                <div class="hint-content-inner">
                  ${content}
                </div>
              </div>
            </div>
          `;
        };

        // 1) General tips - collapsed by default
        if (bullets.length) {
          const content = `
            <ul>
              ${bullets.map((b) => `<li>${escapeHtml(b)}</li>`).join("")}
            </ul>
          `;
          html += createCollapsibleSection('hint-general', 'ğŸ“Œ General Tips', content, false);
        }

        // 2) Structure tip - collapsed by default
        if (structure) {
          const content = `<p>${escapeHtml(structure)}</p>`;
          html += createCollapsibleSection('hint-structure', 'ğŸ—ï¸ Structure Guide', content, false);
        }

        // 3) Extra guidanceï¼ˆåªæœ‰ full æ¨¡å¼ï¼‰- collapsed by default
        if (extra && hintLevel === "full") {
          const content = `<p>${escapeHtml(extra)}</p>`;
          html += createCollapsibleSection('hint-extra', 'âœ¨ Extra Guidance', content, false);
        }

        // 4) Suggested bullets from your resume - collapsed by default
        if (suggestedBullets && suggestedBullets.length) {
          const content = `
            <ul>
              ${suggestedBullets
                .map((b) => {
                  const entry = escapeHtml(b.entry || b.section || "");
                  const text  = escapeHtml(b.text || "");
                  if (entry) {
                    return `<li><span class="hint-entry">${entry}</span><br/>${text}</li>`;
                  }
                  return `<li>${text}</li>`;
                })
                .join("")}
            </ul>
          `;
          html += createCollapsibleSection('hint-bullets', 'ğŸ“ Resume Examples', content, false);
        }

        if (!html) {
          html = "<p class='hint-empty'>No hints available for this question.</p>";
        }

        hintsBox.innerHTML = html;
      }

      // Toggle hint section visibility
      function toggleHintSection(sectionId) {
        const content = document.getElementById(sectionId);
        const toggle = content.previousElementSibling;

        if (content.classList.contains('active')) {
          content.classList.remove('active');
          toggle.classList.remove('active');
        } else {
          content.classList.add('active');
          toggle.classList.add('active');
        }
      }

      // ---------- å•é¡Œè¼‰å…¥ ----------
      async function fetchQuestion(index) {
        setStatus(`Loading question ${index + 1}â€¦`);

        // æŠŠ seconds_left ä¸€èµ·é€çµ¦å¾Œç«¯ï¼ˆåªæœ‰ time mode éœ€è¦ï¼‰
        const payload = {
          session_id: SESSION_CONFIG.session_id,
          index,
        };
        if (lengthType === "time" && typeof remainingSeconds === "number") {
          payload.seconds_left = remainingSeconds;
        }

        const resp = await fetch("/api/mock_next_question", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        const data = await resp.json();
        return data;
      }

      function renderQuestion(q, index) {
        currentQuestionIndex = index;
        currentQuestion = q;

        const tagText = q.tag || "Question";
        qTagEl.textContent  = `${tagText} Â· Q${index + 1}`;
        qTextEl.textContent = q.question || "";

        const suggestedBullets = q.bullets || [];
        renderHints(q.hints || {}, suggestedBullets);

        setStatus(`Question ${index + 1} loaded. Recording has started.`);

        // æ¯ä¸€é¡Œé–‹å§‹æ™‚é‡ç½®ã€Œé€™ä¸€é¡Œã€çš„ transcriptï¼ˆæ•´å ´å…¨æ–‡ä»ç¹¼çºŒç´¯ç©ï¼‰
        currentRealtimeTranscript = "";
        if (rtEl) rtEl.textContent = "";

        // é¡Œç›®é¡¯ç¤ºå®Œæˆå¾Œï¼Œç›´æ¥é–‹å§‹å”¸
        speakQuestion(q.question || "");
      }

      // ---------- ä¸€é¡Œä¸€éŒ„ï¼šé–‹å§‹éŒ„è£½ ----------
      function startRecordingForCurrentQuestion() {
        if (!mediaStream) {
          setStatus("Camera / microphone not ready.");
          return;
        }
        if (!currentQuestion) {
          setStatus("No question loaded yet.");
          return;
        }

        recordingChunks = [];
        try {
          mediaRecorder = new MediaRecorder(mediaStream, { mimeType: "video/webm" });
        } catch (err) {
          console.error("Failed to create MediaRecorder:", err);
          setStatus("Recording is not supported in this browser.");
          setRecordingPill("error", "Recording unavailable");
          return;
        }

        mediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) {
            // JS é™£åˆ—ç”¨ pushï¼Œä¸æ˜¯ append
            recordingChunks.push(e.data);
          }
        };

        mediaRecorder.start();
        setStatus(`Recording answer for Q${currentQuestionIndex + 1}â€¦`);
        setRecordingPill("recording", `Recording Q${currentQuestionIndex + 1}`);
      }

      // ---------- åœæ­¢éŒ„è£½ä¸¦ä¸Šå‚³ç•¶å‰é¡Œç›®ç­”æ¡ˆ ----------
      function stopRecordingAndUploadCurrentAnswer() {
        return new Promise((resolve) => {
          if (!mediaRecorder || mediaRecorder.state !== "recording") {
            resolve();
            return;
          }

          mediaRecorder.onstop = async () => {
            const blob = new Blob(recordingChunks, { type: "video/webm" });

            try {
              setStatus(`Saving your answer for Q${currentQuestionIndex + 1}â€¦`);
              setRecordingPill("uploading", `Saving Q${currentQuestionIndex + 1}â€¦`);

              const meta = {
                session_id: SESSION_CONFIG.session_id,
                index: currentQuestionIndex,
                question_id: currentQuestion.question_id,
                question_text: currentQuestion.question,
              };

              if (currentRealtimeTranscript && currentRealtimeTranscript.trim().length > 0) {
                meta.realtime_transcript = currentRealtimeTranscript.trim();
              }

              const formData = new FormData();
              formData.append("meta", JSON.stringify(meta));
              formData.append("media", blob, `q${currentQuestionIndex + 1}.webm`);

              const resp = await fetch("/api/mock_answer", {
                method: "POST",
                body: formData,
              });
              const data = await resp.json();
              if (!resp.ok) {
                console.error("mock_answer failed:", resp.status, data);
                setStatus("Failed to save / transcribe this answer. Iâ€™ll still move to the next question.");
                setRecordingPill("idle", "Answer not saved");
              } else {
                console.log("mock_answer ok:", data);
                setStatus("Answer saved. Loading the next questionâ€¦");
                setRecordingPill("idle", "Answer saved");
              }
            } catch (err) {
              console.error("Error uploading answer:", err);
              setStatus("Error while uploading this answer. Iâ€™ll still move to the next question.");
              setRecordingPill("idle", "Upload error");
            }

            resolve();
          };

          mediaRecorder.stop();
        });
      }

      // ---------- Start interview ----------
      startBtn.addEventListener("click", async () => {
        if (!mediaStream) {
          setStatus("Camera / microphone not ready.");
          return;
        }

        try {
          startBtn.disabled = true;
          nextBtn.disabled = false;
          endBtn.disabled = false;

          setStatus("Loading your first questionâ€¦");

          const q = await fetchQuestion(0);
          if (q.done) {
            setStatus(q.message || "No questions available for this mock interview.");
            nextBtn.disabled = true;
            endBtn.disabled = true;
            startBtn.disabled = false;
            setRecordingPill("preview", "Camera preview");
            return;
          }

          renderQuestion(q, 0);
          startRecordingForCurrentQuestion();

          // å•Ÿå‹•å€’æ•¸ï¼ˆå¦‚æœæ˜¯æ™‚é–“æ¨¡å¼ï¼‰
          startTimerIfNeeded();
        } catch (err) {
          console.error(err);
          setStatus("Failed to start mock interview.");
          startBtn.disabled = false;
          nextBtn.disabled = true;
          endBtn.disabled = true;
          setRecordingPill("preview", "Camera preview");
        }
      });

      // ---------- Next question ----------
      nextBtn.addEventListener("click", async () => {
        if (currentQuestionIndex < 0) return;

        // æ™‚é–“æ¨¡å¼ä¸”æ™‚é–“å·²åˆ° â†’ ä¸å†å…è¨±æ›æ–°é¡Œ
        if (lengthType === "time" && remainingSeconds === 0) {
          setStatus("Time is up. Please click End interview to finish.");
          nextBtn.disabled = true;
          return;
        }

        // 1) åœæ­¢éŒ„è£½ä¸¦ä¸Šå‚³ç•¶å‰ç­”æ¡ˆ
        await stopRecordingAndUploadCurrentAnswer();

        const nextIndex = currentQuestionIndex + 1;

        // 2) é¡Œæ•¸æ¨¡å¼ï¼šæª¢æŸ¥æ˜¯å¦é”åˆ°é è¨ˆé¡Œæ•¸ï¼ˆfollow-up ä¸ç®—åœ¨é€™å€‹æ•¸å­—ï¼‰
        if (
          lengthType === "questions" &&
          SESSION_CONFIG.num_questions != null &&
          nextIndex >= SESSION_CONFIG.num_questions
        ) {
          nextBtn.disabled = true;
          setStatus("Youâ€™ve reached the planned number of questions. Click End interview to finish.");
          return;
        }

        // 3) è¼‰å…¥ä¸‹ä¸€é¡Œä¸¦é–‹å§‹æ–°ä¸€è¼ªéŒ„å½±
        try {
          const q = await fetchQuestion(nextIndex);
          if (q.done) {
            nextBtn.disabled = true;
            setStatus(q.message || "No more questions. Click End interview to finish.");
            return;
          }

          renderQuestion(q, nextIndex);
          startRecordingForCurrentQuestion();
        } catch (err) {
          console.error(err);
          setStatus("Failed to load the next question.");
        }
      });

      // ---------- End interview ----------
      endBtn.addEventListener("click", async () => {
        // 1) åœæ­¢æœ€å¾Œä¸€é¡ŒéŒ„è£½ä¸¦ä¸Šå‚³
        await stopRecordingAndUploadCurrentAnswer();

        startBtn.disabled = true;
        nextBtn.disabled = true;
        endBtn.disabled = true;
        setStatus("Finalizing your mock interviewâ€¦");
        setRecordingPill("ended", "Interview finished");

        const formData = new FormData();
        formData.append("meta", JSON.stringify({
          session_id: SESSION_CONFIG.session_id,
        }));

        try {
          const resp = await fetch("/api/mock_finish", {
            method: "POST",
            body: formData,
          });
          const data = await resp.json();
          if (!resp.ok) {
            console.error("mock_finish failed:", resp.status, data);
            setStatus("Failed to finalize mock interview.");
            return;
          }

          setStatus("Mock interview saved. Redirecting to your reportâ€¦");

          const url = `/profiles/${encodeURIComponent(
            SESSION_CONFIG.profile_id
          )}/mock_history/${encodeURIComponent(data.session_id)}`;
          window.location.href = url;
        } catch (err) {
          console.error(err);
          setStatus("Error while finalizing mock interview.");
        }
      });
    });
  </script>
</body>
</html>
