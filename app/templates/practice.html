<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Practice ‚Äì Intelliview Coach</title>
  <link rel="stylesheet" href="/static/style.css?v=12" />
  <link rel="stylesheet" href="/static/practice.css?v=12" />
  <link rel="stylesheet" href="/static/global-nav.css?v=12" />

  <style>
    /* ============================================================
       Layout: Active Turn + History
    ============================================================ */
    .active-turn {
      position: sticky;
      top: 92px;
      z-index: 5;
      background: transparent;
    }

    .active-question-shell {
      margin-bottom: 12px;
    }

    .history-shell {
      margin-top: 14px;
    }

    .history-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      cursor: pointer;
      user-select: none;
    }

    .history-header .small-label {
      margin: 0;
    }

    .history-body {
      margin-top: 10px;
    }

    .chat-thread {
      max-height: 340px;
      overflow: auto;
      padding-right: 6px;
    }

    /* ============================================================
       History item (collapsible)
    ============================================================ */
    .history-item {
      border: 1px solid rgba(229, 231, 235, 1);
      border-radius: 14px;
      background: #f9fafb;
      margin-bottom: 10px;
      overflow: hidden;
    }

    .history-item summary {
      list-style: none;
      cursor: pointer;
      padding: 12px 12px;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
    }

    .history-item summary::-webkit-details-marker {
      display: none;
    }

    .history-summary-left {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      flex: 1;
    }

    .history-summary-toprow {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .history-qchip {
      font-size: 12px;
      font-weight: 700;
      color: #111827;
      background: rgba(17, 24, 39, 0.06);
      border-radius: 999px;
      padding: 4px 8px;
      white-space: nowrap;
      border: 1px solid rgba(17, 24, 39, 0.08);
    }

    .history-tag {
      font-size: 12px;
      color: #2563eb;
      background: rgba(37, 99, 235, 0.10);
      border-radius: 999px;
      padding: 4px 8px;
      white-space: nowrap;
      border: 1px solid rgba(37, 99, 235, 0.14);
      font-weight: 650;
    }

    .history-summary-title {
      color: #374151;
      font-size: 13px;
      line-height: 1.35;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }

    .history-chevron {
      color: #9ca3af;
      font-size: 14px;
      margin-top: 2px;
      flex-shrink: 0;
      transition: transform .15s ease;
    }

    .history-item[open] .history-chevron {
      transform: rotate(180deg);
    }

    .history-item .history-content {
      padding: 0 12px 12px 12px;
    }

    .practice-question-card-previous {
      background: rgba(15, 23, 42, 0.02);
      opacity: 0.86;
      box-shadow: none;
    }

    .practice-question-card-previous .small-label {
      color: rgba(15, 23, 42, 0.45);
    }

    .practice-question-card-previous p {
      color: rgba(15, 23, 42, 0.65);
    }

    /* ============================================================
       ‚úÖ Premium Question Card (make it not ugly)
    ============================================================ */

    /* tighten line length to avoid ‚Äúone huge paragraph across the screen‚Äù */
    .practice-main-focused {
      max-width: 980px;
    }

    .practice-question-card {
      border-radius: 18px;
      border: 1px solid rgba(15, 23, 42, 0.10);
      background: #fff;
      padding: 18px 18px 14px 18px;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.06);
    }

    .practice-question-card-current {
      border-color: rgba(37, 99, 235, 0.18);
      box-shadow: 0 14px 34px rgba(15, 23, 42, 0.08);
    }

    .practice-question-card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
    }

    .question-tag {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.08);
      color: rgb(37, 99, 235);
      border: 1px solid rgba(37, 99, 235, 0.18);
      font-weight: 650;
      font-size: 13px;
      letter-spacing: 0.2px;
    }

    .question-counter {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.06);
      border: 1px solid rgba(15, 23, 42, 0.10);
      color: rgba(15, 23, 42, 0.78);
      font-weight: 800;
      font-size: 13px;
      min-width: 44px;
    }

    /* softer labels (not screaming caps) */
    .practice-question-card-section .small-label {
      font-size: 11px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: rgba(15, 23, 42, 0.50);
      margin: 0 0 7px 0;
    }

    .practice-question-card-section p {
      margin: 0;
      line-height: 1.50;
      color: rgba(15, 23, 42, 0.90);
      font-size: 15.5px;
    }

    /* keep content readable */
    .practice-question-card .content-width {
      max-width: 78ch;
    }

    .divider {
      height: 1px;
      background: rgba(15, 23, 42, 0.08);
      margin: 14px 0;
    }

    /* ============================================================
       ‚úÖ Feedback Accordion UI
    ============================================================ */
    .feedback-accordion {
      border: 1px solid rgba(15, 23, 42, 0.10);
      border-radius: 14px;
      background: rgba(15, 23, 42, 0.02);
      overflow: hidden;
      margin-top: 14px;
    }

    .feedback-accordion summary {
      list-style: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 12px;
    }

    .feedback-accordion summary::-webkit-details-marker {
      display: none;
    }

    .feedback-summary-left {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .score-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      font-weight: 800;
      border-radius: 999px;
      padding: 5px 10px;
      border: 1px solid rgba(15, 23, 42, 0.12);
      background: #fff;
      color: rgba(15, 23, 42, 0.86);
      white-space: nowrap;
    }

    .score-chip.good {
      border-color: rgba(16, 185, 129, 0.30);
      background: rgba(16, 185, 129, 0.10);
      color: rgba(6, 95, 70, 0.95);
    }

    .score-chip.bad {
      border-color: rgba(239, 68, 68, 0.30);
      background: rgba(239, 68, 68, 0.10);
      color: rgba(127, 29, 29, 0.95);
    }

    .feedback-summary-title {
      font-size: 13px;
      color: rgba(15, 23, 42, 0.70);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 52ch;
    }

    .feedback-chevron {
      color: rgba(15, 23, 42, 0.40);
      font-size: 13px;
      transition: transform .15s ease;
      flex-shrink: 0;
    }

    .feedback-accordion[open] .feedback-chevron {
      transform: rotate(180deg);
    }

    .feedback-body {
      padding: 12px 12px 12px 12px;
      background: #fff;
      border-top: 1px solid rgba(15, 23, 42, 0.08);
    }

    .answer-clamp {
      display: -webkit-box;
      -webkit-line-clamp: 4;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .feedback-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 12px;
    }

    @media (max-width: 760px) {
      .feedback-grid {
        grid-template-columns: 1fr;
      }
      .feedback-summary-title {
        max-width: 36ch;
      }
    }

    .callout {
      border-radius: 12px;
      border: 1px solid rgba(15, 23, 42, 0.10);
      background: rgba(15, 23, 42, 0.02);
      padding: 10px 10px;
    }

    .callout.good {
      border-color: rgba(16, 185, 129, 0.26);
      background: rgba(16, 185, 129, 0.08);
    }

    .callout.improve {
      border-color: rgba(245, 158, 11, 0.30);
      background: rgba(245, 158, 11, 0.08);
    }

    .callout .title {
      font-weight: 800;
      font-size: 13px;
      color: rgba(15, 23, 42, 0.78);
      margin-bottom: 6px;
    }

    .callout p {
      font-size: 14px;
      color: rgba(15, 23, 42, 0.78);
      line-height: 1.5;
    }
  </style>
</head>

<body>
  <div class="app-container">
    <!-- Top nav -->
    <header class="top-nav">
      <div class="nav-left">
        <div class="logo-dot"></div>
        <span class="logo-text">Intelliview&nbsp;Coach</span>
      </div>
      <nav class="nav-links">
        <a href="/">Home</a>
        <a href="{{ request.url_for('resume_page') }}">Resume</a>
        <a href="{{ request.url_for('profiles_page') }}">Profiles</a>
        <a href="#" class="nav-active">Mock Interview (Practice)</a>
      </nav>
    </header>

    <main class="practice-page">
      <!-- Top bar with job title and status -->
      <div class="practice-top-bar">
        <div class="top-bar-left">
          <a href="/profiles" class="back-btn" title="Back to Profiles">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" class="back-icon" stroke="currentColor"
              stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M19 12H5M12 19l-7-7 7-7" />
            </svg>
          </a>
          <button class="hamburger-btn" id="hamburger-btn" onclick="toggleDrawer()">
            <span class="hamburger-icon">‚ò∞</span>
          </button>
          <div class="top-bar-info">
            <h1 class="job-title" id="job-title">{{ job_title }}{% if company %}, {{ company }}{% endif %}</h1>
            <div id="progress-chip-top" class="status-chip status-loading">
              <span class="status-dot"></span>
              <span id="progress-text-top">Q1 ¬∑ Ready</span>
            </div>
          </div>
        </div>
        <div class="top-bar-right">
          <label class="toggle-switch">
            <input type="checkbox" id="show-helper-toggle" onchange="toggleHelperColumn()">
            <span class="toggle-slider"></span>
            <span class="toggle-label">Show AI Coach</span>
          </label>
        </div>
      </div>

      <div class="practice-layout-container" id="practice-layout-container">
        <section class="practice-main-focused">
          <div id="custom-question-panel" class="custom-question-panel" style="display:none;">
            <div class="small-label">Custom question</div>
            <textarea id="custom-question-text" rows="3" class="textarea"
              placeholder="Type your interview question here, then click 'Use my own question'."></textarea>
          </div>

          <div class="active-turn" id="active-turn">
            <div class="active-question-shell" id="active-question-shell">
              <div id="active-question-slot"></div>
            </div>
          </div>

          <div class="history-shell card-section" id="history-shell">
            <div class="history-header" id="history-header">
              <div class="small-label">History (click to expand / collapse)</div>
              <div class="history-chevron" id="history-chevron">‚ñº</div>
            </div>

            <div class="history-body" id="history-body" style="display:none;">
              <div class="chat-thread" id="chat-thread"></div>
            </div>
          </div>

          <div class="practice-answer-block card-section">
            <div class="small-label">Your answer</div>
            <textarea id="user-answer" rows="6" class="textarea"
              placeholder="Type your answer here. You can also record an audio/video answer."></textarea>

            <div class="recording-controls">
              <div class="recording-buttons">
                <button class="btn ghost-btn" id="open-recorder-btn">
                  üé• Open recorder
                </button>
              </div>
              <p class="recording-message-small">
                Choose audio or video in the recorder. Your answer will be saved here with this question.
              </p>

              <div id="recording-summary" class="recording-summary hidden">
                <div class="recording-summary-main">
                  <div class="recording-summary-dot"></div>
                  <div id="recording-summary-meta" class="recording-summary-meta">
                    Video ¬∑ 00:00
                  </div>
                </div>
                <audio id="recording-playback-audio" class="recording-playback hidden" controls></audio>
                <video id="recording-playback-video" class="recording-playback hidden" controls playsinline></video>
              </div>
            </div>
          </div>

          <div class="practice-main-actions">
            <button class="btn ghost-btn" id="custom-question-btn">Use my own question</button>
            <button class="btn ghost-btn" id="save-answer-btn">Save answer</button>
            <button class="btn primary-btn" id="followup-question-btn">Ask follow-up</button>
            <button class="btn primary-btn" id="next-question-btn">Next question</button>
          </div>
        </section>

        <aside class="practice-helper-column" id="practice-helper-column" style="display: none;">
          <div class="helper-card">
            <div class="helper-card-header" onclick="togglePracticeSection('bullets-content')">
              <div class="helper-header-left">
                <span class="helper-icon">üìù</span>
                <span class="helper-title">Suggested Bullets</span>
              </div>
              <span class="helper-toggle-icon">‚ñº</span>
            </div>
            <div class="helper-card-content" id="bullets-content">
              <ul id="bullet-hints" class="bullet-hints">
                <li>(Loading...)</li>
              </ul>
            </div>
          </div>

          <div class="helper-card">
            <div class="helper-card-header">
              <div class="helper-header-left">
                <span class="helper-icon">‚ú®</span>
                <span class="helper-title">AI Sample Answer</span>
              </div>
            </div>

            <div class="helper-card-content">
              <div class="helper-actions">
                <button class="btn small-btn ghost-btn" id="generate-answer-btn">Generate</button>
                <button class="btn small-btn ghost-btn" id="toggle-sample-btn">Reveal</button>
              </div>

              <div class="sample-content blurred" id="sample-answer-box">
                <div id="sample-hint-block" class="sample-inner-block">
                  <div class="small-label">Hint</div>
                  <p id="sample-hint-text">Hint will appear here.</p>
                </div>

                <div class="sample-answer-block sample-inner-block">
                  <div class="small-label">Answer</div>
                  <p id="sample-answer-text">Sample answer will appear here.</p>
                </div>

                <div class="sample-rationale-block sample-inner-block">
                  <div class="small-label">Rationale</div>
                  <p id="sample-rationale-text">Why this works...</p>
                </div>
              </div>
              <p class="sample-hint-footer">Generated using resume bullets + JD.</p>
            </div>
          </div>
        </aside>
      </div>

      <div class="drawer-overlay" id="drawer-overlay" onclick="closeDrawer()"></div>
      <aside class="auxiliary-drawer" id="auxiliary-drawer">
        <div class="drawer-header">
          <div class="drawer-title-wrapper">
            <div class="profile-header-info">
              <div class="profile-role-text">{{ job_title }}</div>
              <div class="profile-id-text">{{ profile_id }}</div>
            </div>
          </div>
          <button class="close-drawer-btn" onclick="closeDrawer()">√ó</button>
        </div>
        <div class="drawer-content scroll-y">
          <div class="drawer-menu-list">
            <div class="drawer-menu-item">
              <div class="menu-item-header">
                <span class="menu-icon">‚öôÔ∏è</span>
                <span class="menu-label">Practice Mode</span>
              </div>
              <div class="menu-control">
                <select id="question-mode" class="clean-select">
                  <option value="auto">Auto (from JD)</option>
                  <option value="behavioral">Behavioral</option>
                  <option value="project">Project deep dive</option>
                  <option value="technical">Technical</option>
                  <option value="case">Case reasoning</option>
                  <option value="custom">Custom question</option>
                </select>
              </div>
            </div>

            <div id="behavioral-type-wrapper" class="drawer-menu-item submenu-item" style="display: none;">
              <div class="menu-control">
                <label class="small-label">Focus Area</label>
                <select id="behavioral-type-select" class="clean-select">
                  <option value="random">Random</option>
                  <option value="teamwork">Teamwork</option>
                  <option value="conflict">Conflict</option>
                  <option value="leadership">Leadership</option>
                  <option value="failure">Failure / mistakes</option>
                  <option value="strengths_weaknesses">Strengths & weaknesses</option>
                </select>
              </div>
            </div>

            <div id="project-entry-wrapper" class="drawer-menu-item submenu-item" style="display: none;">
              <div class="menu-control">
                <label class="small-label">Select Experience</label>
                <select id="project-entry-select" class="clean-select">
                  <option value="">Select an entry‚Ä¶</option>
                </select>
              </div>
            </div>

            <div class="drawer-menu-item">
              <div class="menu-item-header">
                <span class="menu-icon">üìä</span>
                <span class="menu-label">Session Stats</span>
              </div>
              <div id="stats-summary" class="menu-content-box">
                <p class="stats-text">Loading...</p>
              </div>
            </div>

            <div class="drawer-menu-item">
              <div class="menu-item-header">
                <span class="menu-icon">üïí</span>
                <span class="menu-label">History</span>
              </div>
              <div class="menu-actions">
                <a href="{{ request.url_for('practice_history_page', profile_id=profile_id) }}"
                  class="btn small-btn secondary-btn full-width-btn">
                  View Full History
                </a>
              </div>
              <div id="history-panel" class="history-preview-list" style="display:none;">
                <ul id="history-list"></ul>
              </div>
              <div class="practice-history-toggle" id="history-toggle"
                style="margin-top:8px; display:flex; justify-content:center;">
                <button class="btn small-btn ghost-btn" id="history-toggle-btn">Show / Hide Recent</button>
              </div>
            </div>
          </div>
        </div>
      </aside>

    </main>
  </div>

  <div class="coach-launcher" id="coach-launcher">
    <button class="coach-launcher-btn">
      <span class="coach-launcher-icon">üí¨</span>
      <span class="coach-launcher-label">Coach</span>
    </button>
  </div>

  <div class="coach-chat-wrapper" id="coach-chat-wrapper" style="display: none;">
    <div class="coach-chat-card">
      <div class="coach-chat-header">
        <span class="coach-chat-title">Coach chat</span>
        <button class="coach-chat-close" id="coach-chat-close">√ó</button>
      </div>

      <div class="coach-chat-body">
        <div id="coach-chat-thread" class="coach-chat-thread"></div>

        <div class="coach-input-row">
          <textarea id="coach-input" class="coach-input" rows="3"
            placeholder="Tell the coach how you'd like to adjust the answer (e.g., focus on a different project, shorten it, etc.)"></textarea>
          <button class="coach-send-btn" id="coach-send-btn">Send</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Recorder modal -->
  <div class="rec-modal hidden" id="recorder-modal">
    <div class="rec-modal-dialog">
      <div class="rec-modal-header">
        <div>
          <div class="rec-modal-title">Record your answer</div>
          <div class="rec-modal-subtitle">
            Choose audio or video, then click <strong>Start</strong> when you're ready.
          </div>
        </div>
        <button class="rec-close-btn" id="rec-close-btn">√ó</button>
      </div>

      <div class="rec-current-question" id="rec-current-question"></div>

      <div class="rec-mode-toggle">
        <button id="rec-mode-audio" type="button">Audio only</button>
        <button id="rec-mode-video" type="button" class="active">Video + audio</button>
      </div>

      <div class="rec-preview-shell">
        <video id="rec-preview-video" class="rec-preview-video" autoplay muted playsinline></video>
        <div id="rec-audio-placeholder" class="rec-audio-placeholder hidden">
          Audio-only mode selected. Your microphone will be recorded after you click Start.
        </div>
      </div>

      <div class="rec-bottom-row">
        <div>
          <span class="rec-timer" id="rec-timer">00:00</span>
          <span class="rec-status" id="rec-status"></span>
        </div>
        <div class="rec-actions">
          <button class="btn ghost-btn" id="rec-stop-btn" disabled>Stop</button>
          <button class="btn primary-btn" id="rec-start-btn">Start</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const PROFILE_ID = "{{ profile_id }}";

    // ---- Global state ----
    let CURRENT_MODE = "auto";
    let CURRENT_BEHAVIORAL_TYPE = "random";
    let CURRENT_ENTRY_KEY = null;
    let CURRENT_QUESTION = "";
    let QUESTION_COUNT = 0;
    let currentQuestionCard = null;

    // Follow-up state
    let CURRENT_BASE_QUESTION = "";
    let CURRENT_THREAD_ID = null;
    let CURRENT_IS_FOLLOWUP = false;
    let FOLLOWUP_DONE = false;
    let CURRENT_LAST_ANSWER = "";

    // ---- Recording state (modal) ----
    let REC_MODE = "video"; // "audio" | "video"
    let recMediaStream = null;
    let recMediaRecorder = null;
    let recChunks = [];
    let recStartTime = null;
    let recTimerId = null;
    let lastRecordingUrl = null;
    let lastRecordingType = null;
    let lastRecordingDurationMs = null;

    // Ïã§Ï†ú ÏóÖÎ°úÎìú Blob/meta
    let currentMediaBlob = null;
    let currentMediaMeta = null;

    // dragging
    let isRecDragging = false;
    let recDragStartX = 0;
    let recDragStartY = 0;
    let recDialogStartLeft = 0;
    let recDialogStartTop = 0;

    // ---- DOM refs ----
    const questionModeSelect = document.getElementById("question-mode");
    const behavioralTypeWrapper = document.getElementById("behavioral-type-wrapper");
    const behavioralTypeSelect = document.getElementById("behavioral-type-select");
    const projectEntryWrapper = document.getElementById("project-entry-wrapper");
    const projectEntrySelect = document.getElementById("project-entry-select");
    const customQuestionPanel = document.getElementById("custom-question-panel");
    const customQuestionText = document.getElementById("custom-question-text");
    const customQuestionBtn = document.getElementById("custom-question-btn");

    const chatThread = document.getElementById("chat-thread");
    const activeQuestionSlot = document.getElementById("active-question-slot");
    const historyHeader = document.getElementById("history-header");
    const historyBody = document.getElementById("history-body");
    const historyChevron = document.getElementById("history-chevron");

    const userAnswerTextarea = document.getElementById("user-answer");
    const bulletHintsList = document.getElementById("bullet-hints");

    const nextQuestionBtn = document.getElementById("next-question-btn");
    const generateAnswerBtn = document.getElementById("generate-answer-btn");
    const toggleSampleBtn = document.getElementById("toggle-sample-btn");
    const saveAnswerBtn = document.getElementById("save-answer-btn");
    const sampleBox = document.getElementById("sample-answer-box");
    const followupQuestionBtn = document.getElementById("followup-question-btn");

    const historyList = document.getElementById("history-list");
    const historyPanel = document.getElementById("history-panel");
    const historyToggleBtn = document.getElementById("history-toggle-btn");
    const historyToggleRow = document.getElementById("history-toggle");

    const sampleHintText = document.getElementById("sample-hint-text");
    const sampleAnswerText = document.getElementById("sample-answer-text");
    const sampleRationaleText = document.getElementById("sample-rationale-text");

    const coachChatThread = document.getElementById("coach-chat-thread");
    const coachInput = document.getElementById("coach-input");
    const coachSendBtn = document.getElementById("coach-send-btn");
    const coachLauncher = document.getElementById("coach-launcher");
    const coachChatWrapper = document.getElementById("coach-chat-wrapper");
    const coachChatClose = document.getElementById("coach-chat-close");

    // Recording summary + modal DOM
    const openRecorderBtn = document.getElementById("open-recorder-btn");
    const recordingSummary = document.getElementById("recording-summary");
    const recordingSummaryMeta = document.getElementById("recording-summary-meta");
    const recordingPlaybackAudio = document.getElementById("recording-playback-audio");
    const recordingPlaybackVideo = document.getElementById("recording-playback-video");

    const recorderModal = document.getElementById("recorder-modal");
    const recDialog = recorderModal ? recorderModal.querySelector(".rec-modal-dialog") : null;
    const recModeAudioBtn = document.getElementById("rec-mode-audio");
    const recModeVideoBtn = document.getElementById("rec-mode-video");
    const recPreviewVideo = document.getElementById("rec-preview-video");
    const recAudioPlaceholder = document.getElementById("rec-audio-placeholder");
    const recStartBtn = document.getElementById("rec-start-btn");
    const recStopBtn = document.getElementById("rec-stop-btn");
    const recCloseBtn = document.getElementById("rec-close-btn");
    const recTimerSpan = document.getElementById("rec-timer");
    const recStatusSpan = document.getElementById("rec-status");

    let PROJECT_ENTRIES = [];
    let COACH_CHAT_HISTORY = [];
    let LAST_SAMPLE_ANSWER = "";

    // ---- Status helper ----
    function setProgress(statusClass, text) {
      const chip2 = document.getElementById("progress-chip-top");
      const text2 = document.getElementById("progress-text-top");
      if (chip2) chip2.className = "status-chip " + statusClass;
      if (text2) text2.textContent = text;
    }

    // ---- Drawer Logic ----
    function toggleDrawer() {
      const drawer = document.getElementById("auxiliary-drawer");
      const overlay = document.getElementById("drawer-overlay");
      if (drawer) drawer.classList.toggle("open");
      if (overlay) overlay.classList.toggle("open");
    }

    function closeDrawer() {
      const drawer = document.getElementById("auxiliary-drawer");
      const overlay = document.getElementById("drawer-overlay");
      if (drawer) drawer.classList.remove("open");
      if (overlay) overlay.classList.remove("open");
    }

    // ---- Helper Column Logic ----
    function toggleHelperColumn() {
      const checkbox = document.getElementById("show-helper-toggle");
      const layoutContainer = document.getElementById("practice-layout-container");
      const col = document.getElementById("practice-helper-column");

      if (checkbox && checkbox.checked) {
        if (layoutContainer) layoutContainer.classList.add("split-active");
        if (col) col.style.display = "flex";
      } else {
        if (layoutContainer) layoutContainer.classList.remove("split-active");
        if (col) col.style.display = "none";
      }
    }

    function togglePracticeSection(id) {
      const el = document.getElementById(id);
      if (el) {
        el.style.display = (el.style.display === 'none' || el.style.display === '') ? 'block' : 'none';
      }
    }

    // History UI toggle
    if (historyHeader && historyBody) {
      historyHeader.addEventListener("click", () => {
        const isOpen = historyBody.style.display !== "none";
        historyBody.style.display = isOpen ? "none" : "block";
        if (historyChevron) historyChevron.textContent = isOpen ? "‚ñº" : "‚ñ≤";
      });
    }

    function generateThreadId() {
      return "thread-" + Date.now() + "-" + Math.random().toString(36).slice(2, 8);
    }

    function updateFollowupButtonState() {
      if (!followupQuestionBtn || !userAnswerTextarea) return;
      const typed = userAnswerTextarea.value.trim();
      const hasTyped = typed.length > 0;
      const hasSaved = CURRENT_LAST_ANSWER && CURRENT_LAST_ANSWER.trim().length > 0;

      followupQuestionBtn.disabled = !(CURRENT_QUESTION && !FOLLOWUP_DONE && (hasTyped || hasSaved));
    }

    if (followupQuestionBtn) followupQuestionBtn.disabled = true;
    if (userAnswerTextarea && followupQuestionBtn) {
      userAnswerTextarea.addEventListener("input", updateFollowupButtonState);
    }

    // Coach launcher open/close
    const coachChatCard = document.querySelector("#coach-chat-wrapper .coach-chat-card");

    if (coachLauncher && coachChatWrapper) {
      coachLauncher.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        coachChatWrapper.style.display = "block";
      });
    }

    if (coachChatClose && coachChatWrapper) {
      coachChatClose.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        coachChatWrapper.style.display = "none";
      });
    }

    if (coachChatWrapper) {
      coachChatWrapper.addEventListener("click", (e) => {
        if (e.target === coachChatWrapper) coachChatWrapper.style.display = "none";
      });
    }

    if (coachChatCard) {
      coachChatCard.addEventListener("click", (e) => e.stopPropagation());
      coachChatCard.addEventListener("mousedown", (e) => e.stopPropagation());
    }

    // ============================================================
    // Recording helpers (modal)  Ôºà‰Ω†ÂéüÊú¨ÂÆåÊï¥‰øùÁïôÔºâ
    // ============================================================
    function formatTime(ms) {
      const totalSec = Math.floor(ms / 1000);
      const m = String(Math.floor(totalSec / 60)).padStart(2, "0");
      const s = String(totalSec % 60).padStart(2, "0");
      return `${m}:${s}`;
    }

    function setRecorderStatus(msg) {
      if (recStatusSpan) recStatusSpan.textContent = msg || "";
    }

    function resetRecorderState(keepStream) {
      if (recTimerId) { clearInterval(recTimerId); recTimerId = null; }
      recStartTime = null;
      recChunks = [];

      if (recStartBtn) recStartBtn.disabled = false;
      if (recStopBtn) recStopBtn.disabled = true;
      if (recTimerSpan) recTimerSpan.textContent = "00:00";
      if (recStatusSpan) recStatusSpan.textContent = "";

      if (!keepStream && recMediaStream) {
        recMediaStream.getTracks().forEach((t) => t.stop());
        recMediaStream = null;
      }
      if (!keepStream && REC_MODE === "video" && recPreviewVideo) {
        recPreviewVideo.srcObject = null;
      }
      recMediaRecorder = null;
    }

    function centerRecorderDialog() {
      if (!recDialog || recorderModal.classList.contains("hidden")) return;
      recDialog.style.left = "auto";
      recDialog.style.top = "auto";

      const rect = recDialog.getBoundingClientRect();
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const left = Math.max(16, (vw - rect.width) / 2);
      const top = Math.max(16, (vh - rect.height) / 2);
      recDialog.style.left = left + "px";
      recDialog.style.top = top + "px";
    }

    function setupRecorderDragging() {
      if (!recDialog) return;
      const header = recDialog.querySelector(".rec-modal-header");
      if (!header) return;
      header.style.cursor = "move";

      header.onmousedown = (e) => {
        isRecDragging = true;
        recDialog.classList.add("dragging");
        recDragStartX = e.clientX;
        recDragStartY = e.clientY;

        const rect = recDialog.getBoundingClientRect();
        recDialogStartLeft = rect.left;
        recDialogStartTop = rect.top;

        document.addEventListener("mousemove", onRecDragMove);
        document.addEventListener("mouseup", onRecDragEnd);
      };

      function onRecDragMove(e) {
        if (!isRecDragging) return;
        const dx = e.clientX - recDragStartX;
        const dy = e.clientY - recDragStartY;

        let newLeft = recDialogStartLeft + dx;
        let newTop = recDialogStartTop + dy;

        const margin = 8;
        const maxLeft = window.innerWidth - margin;
        const maxTop = window.innerHeight - margin;

        newLeft = Math.min(Math.max(newLeft, margin - recDialog.offsetWidth), maxLeft);
        newTop = Math.min(Math.max(newTop, margin - recDialog.offsetHeight), maxTop);

        recDialog.style.left = newLeft + "px";
        recDialog.style.top = newTop + "px";
      }

      function onRecDragEnd() {
        if (!isRecDragging) return;
        isRecDragging = false;
        recDialog.classList.remove("dragging");
        document.removeEventListener("mousemove", onRecDragMove);
        document.removeEventListener("mouseup", onRecDragEnd);
      }
    }

    async function ensureVideoPreviewStream() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setRecorderStatus("Your browser does not support recording.");
        return;
      }
      try {
        if (!recMediaStream) {
          recMediaStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
            video: { width: 1280, height: 720 },
          });
        }
        if (recPreviewVideo) recPreviewVideo.srcObject = recMediaStream;
        if (recAudioPlaceholder) recAudioPlaceholder.classList.add("hidden");
        if (recPreviewVideo) recPreviewVideo.classList.remove("hidden");
        setRecorderStatus("Camera is on. Click Start when you're ready.");
      } catch (err) {
        console.error("ensureVideoPreviewStream error", err);
        setRecorderStatus("Camera / microphone permission denied or unavailable.");
      }
    }

    function setRecMode(mode) {
      REC_MODE = mode === "audio" ? "audio" : "video";

      if (REC_MODE === "audio") {
        recModeAudioBtn.classList.add("active");
        recModeVideoBtn.classList.remove("active");

        if (recAudioPlaceholder) recAudioPlaceholder.classList.remove("hidden");
        if (recPreviewVideo) {
          recPreviewVideo.classList.add("hidden");
          recPreviewVideo.srcObject = null;
        }
        if (recMediaStream) {
          recMediaStream.getTracks().forEach((t) => t.stop());
          recMediaStream = null;
        }
        setRecorderStatus("Audio-only mode selected.");
      } else {
        recModeAudioBtn.classList.remove("active");
        recModeVideoBtn.classList.add("active");
        if (!recorderModal.classList.contains("hidden")) ensureVideoPreviewStream();
      }
      resetRecorderState(true);
    }

    function openRecorderModal() {
      if (!recorderModal) return;
      recorderModal.classList.remove("hidden");
      const recQ = document.getElementById("rec-current-question");
      if (recQ) recQ.textContent = `Q${QUESTION_COUNT} ‚Äì ${CURRENT_QUESTION}`;
      setRecMode(REC_MODE);
      centerRecorderDialog();
      setupRecorderDragging();
      window.addEventListener("resize", centerRecorderDialog);
      if (REC_MODE === "video") ensureVideoPreviewStream();
      else setRecorderStatus("Audio-only mode. Click Start when you're ready.");
      resetRecorderState(true);
    }

    function closeRecorderModal() {
      if (!recorderModal) return;
      if (recMediaRecorder && recMediaRecorder.state === "recording") {
        try { recMediaRecorder.stop(); } catch (e) { }
      }
      resetRecorderState(false);
      if (recMediaStream) {
        recMediaStream.getTracks().forEach((t) => t.stop());
        recMediaStream = null;
      }
      if (recPreviewVideo) recPreviewVideo.srcObject = null;
      recorderModal.classList.add("hidden");
      window.removeEventListener("resize", centerRecorderDialog);
    }

    async function startRecording() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setRecorderStatus("Your browser does not support recording.");
        return;
      }
      try {
        resetRecorderState(true);
        if (recStartBtn) recStartBtn.disabled = true;
        if (recStopBtn) recStopBtn.disabled = false;

        if (REC_MODE === "audio") {
          if (!recMediaStream) recMediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          if (recPreviewVideo) recPreviewVideo.srcObject = null;
        } else {
          if (!recMediaStream) await ensureVideoPreviewStream();
        }

        const mime = REC_MODE === "audio" ? "audio/webm" : "video/webm";
        recMediaRecorder = new MediaRecorder(recMediaStream, { mimeType: mime });
        const thisRecordingMode = REC_MODE;
        recChunks = [];

        recMediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) recChunks.push(e.data);
        };

        recMediaRecorder.onstop = () => {
          const blob = new Blob(recChunks, { type: mime });
          currentMediaBlob = blob;
          currentMediaMeta = {
            type: thisRecordingMode === "audio" ? "audio" : "video",
            durationMs: recStartTime ? (Date.now() - recStartTime) : null,
          };

          if (lastRecordingUrl) URL.revokeObjectURL(lastRecordingUrl);
          lastRecordingUrl = URL.createObjectURL(blob);
          lastRecordingType = thisRecordingMode;
          lastRecordingDurationMs = recStartTime ? Date.now() - recStartTime : null;

          if (recordingSummary) recordingSummary.classList.remove("hidden");
          if (recordingSummaryMeta) {
            const dur = lastRecordingDurationMs ? formatTime(lastRecordingDurationMs) : "";
            recordingSummaryMeta.textContent = `${thisRecordingMode === "audio" ? "Audio" : "Video"} ¬∑ ${dur}`;
          }

          if (thisRecordingMode === "audio") {
            recordingPlaybackAudio.classList.remove("hidden");
            recordingPlaybackAudio.src = lastRecordingUrl;
            recordingPlaybackVideo.classList.add("hidden");
            recordingPlaybackVideo.src = "";
          } else {
            recordingPlaybackVideo.classList.remove("hidden");
            recordingPlaybackVideo.src = lastRecordingUrl;
            recordingPlaybackAudio.classList.add("hidden");
            recordingPlaybackAudio.src = "";
          }

          if (recPreviewVideo) recPreviewVideo.srcObject = null;
          if (recMediaStream) {
            recMediaStream.getTracks().forEach((t) => t.stop());
            recMediaStream = null;
          }

          setRecorderStatus("Recording saved.");
          if (recStartBtn) recStartBtn.disabled = false;
          if (recStopBtn) recStopBtn.disabled = true;
          if (recTimerId) { clearInterval(recTimerId); recTimerId = null; }
          if (recTimerSpan) recTimerSpan.textContent = "00:00";
          closeRecorderModal();
        };

        recMediaRecorder.start();
        recStartTime = Date.now();
        setRecorderStatus("Recording‚Ä¶");

        if (recTimerId) clearInterval(recTimerId);
        recTimerId = setInterval(() => {
          if (!recStartTime) return;
          const elapsed = Date.now() - recStartTime;
          if (recTimerSpan) recTimerSpan.textContent = formatTime(elapsed);
        }, 500);
      } catch (err) {
        console.error("startRecording error", err);
        setRecorderStatus("Permission denied or device unavailable.");
        if (recStartBtn) recStartBtn.disabled = false;
        if (recStopBtn) recStopBtn.disabled = true;
        if (recMediaStream) {
          recMediaStream.getTracks().forEach((t) => t.stop());
          recMediaStream = null;
        }
      }
    }

    function stopRecording() {
      if (!recMediaRecorder || recMediaRecorder.state !== "recording") return;
      recMediaRecorder.stop();
      setRecorderStatus("Finishing recording‚Ä¶");
      if (recStopBtn) recStopBtn.disabled = true;
      if (recTimerId) { clearInterval(recTimerId); recTimerId = null; }
      if (recTimerSpan) recTimerSpan.textContent = "00:00";
      if (recMediaStream) {
        recMediaStream.getTracks().forEach((t) => t.stop());
        recMediaStream = null;
      }
      if (recPreviewVideo) recPreviewVideo.srcObject = null;
    }

    // ============================================================
    // Suggested bullets
    // ============================================================
    function renderBulletHints(bullets) {
      if (!bulletHintsList) return;
      bulletHintsList.innerHTML = "";

      if (!bullets || !bullets.length) {
        const li = document.createElement("li");
        li.textContent = "No suggested bullets. You can still answer from your experience.";
        bulletHintsList.appendChild(li);
        return;
      }

      const grouped = {};
      bullets.forEach((b) => {
        const entryTitle = b.entry || "General";
        if (!grouped[entryTitle]) grouped[entryTitle] = [];
        grouped[entryTitle].push(b);
      });

      Object.entries(grouped).forEach(([entryTitle, list]) => {
        const li = document.createElement("li");

        const entryHeader = document.createElement("div");
        entryHeader.className = "small-label";
        entryHeader.textContent = entryTitle;
        li.appendChild(entryHeader);

        list.forEach((b) => {
          const row = document.createElement("label");
          row.className = "bullet-hint-row";

          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.dataset.section = b.section || "";
          cb.dataset.entry = b.entry || entryTitle;
          cb.dataset.text = b.text || "";

          const span = document.createElement("span");
          span.textContent = b.text || "";

          row.appendChild(cb);
          row.appendChild(span);
          li.appendChild(row);
        });

        bulletHintsList.appendChild(li);
      });
    }

    // ============================================================
    // Floating coach chat
    // ============================================================
    function appendCoachBubble(role, text) {
      if (!coachChatThread) return;
      const row = document.createElement("div");
      row.className = "chat-row " + (role === "assistant" ? "chat-row-assistant" : "chat-row-user");

      const bubble = document.createElement("div");
      bubble.className = "chat-bubble";
      const p = document.createElement("p");
      p.textContent = text;
      bubble.appendChild(p);

      row.appendChild(bubble);
      coachChatThread.appendChild(row);
      coachChatThread.scrollTop = coachChatThread.scrollHeight;
    }

    async function sendCoachMessage() {
      const msg = coachInput.value.trim();
      if (!msg) return;

      if (!CURRENT_QUESTION) {
        setProgress("status-error", "No active question. Click 'Next question' first.");
        return;
      }

      appendCoachBubble("user", msg);
      COACH_CHAT_HISTORY.push({ role: "user", content: msg });
      coachInput.value = "";

      const selectedBullets = [];
      document.querySelectorAll("#bullet-hints input[type='checkbox']:checked")
        .forEach((cb) => {
          selectedBullets.push({
            section: cb.dataset.section,
            entry: cb.dataset.entry,
            text: cb.dataset.text,
          });
        });

      const payload = {
        profile_id: PROFILE_ID,
        mode: CURRENT_MODE,
        question: CURRENT_QUESTION,
        user_message: msg,
        sample_answer: LAST_SAMPLE_ANSWER || null,
        bullets: selectedBullets.length ? selectedBullets : null,
        history: COACH_CHAT_HISTORY,
      };

      setProgress("status-loading", `Q${QUESTION_COUNT} ¬∑ Coach is thinking‚Ä¶`);

      try {
        const resp = await fetch("/api/coach_chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!resp.ok) {
          console.error("coach_chat failed", resp.status, await resp.text());
          setProgress("status-error", "Coach chat failed.");
          return;
        }

        const data = await resp.json();
        const reply = data.reply || "(No reply)";

        COACH_CHAT_HISTORY.push({ role: "assistant", content: reply });
        appendCoachBubble("assistant", reply);

        setProgress("status-success", `Q${QUESTION_COUNT} ¬∑ Coach replied`);
      } catch (err) {
        console.error(err);
        setProgress("status-error", "Coach chat error.");
      }
    }

    if (coachSendBtn) coachSendBtn.addEventListener("click", sendCoachMessage);

    // ============================================================
    // Project entries
    // ============================================================
    async function loadProjectEntriesOnce() {
      if (PROJECT_ENTRIES.length > 0) return;
      try {
        const resp = await fetch(`/api/profile_entries/${PROFILE_ID}`);
        if (!resp.ok) { console.error("Failed to load profile entries", resp.status); return; }
        const data = await resp.json();
        PROJECT_ENTRIES = (data.entries || []);

        projectEntrySelect.innerHTML = "";
        const opt0 = document.createElement("option");
        opt0.value = "";
        opt0.textContent = "Select an entry‚Ä¶";
        projectEntrySelect.appendChild(opt0);

        const MAX_LABEL_LEN = 60;
        PROJECT_ENTRIES.forEach((item) => {
          const opt = document.createElement("option");
          opt.value = item.entry_key;
          let label = item.label || "";
          opt.textContent = label.length > MAX_LABEL_LEN ? (label.slice(0, MAX_LABEL_LEN) + "‚Ä¶") : label;
          opt.title = label;
          projectEntrySelect.appendChild(opt);
        });
      } catch (err) { console.error(err); }
    }

    // ============================================================
    // ‚úÖ Question card (Active Turn + History) ‚Äî redesigned feedback
    // ============================================================

    function makeScoreChip(score) {
      const chip = document.createElement("span");
      chip.className = "score-chip";
      if (score === undefined || score === null) {
        chip.textContent = "Score ¬∑ N/A";
        return chip;
      }
      chip.textContent = `Score ¬∑ ${score}/10`;
      if (score >= 7) chip.classList.add("good");
      if (score <= 3) chip.classList.add("bad");
      return chip;
    }

    function renderFeedback(card, payload) {
      // payload: { score, strengths, improvements, answerText, hasMediaOnly }
      const holder = card?._feedbackHolder;
      if (!holder) return;

      holder.innerHTML = "";

      const details = document.createElement("details");
      details.className = "feedback-accordion";

      const summary = document.createElement("summary");
      const left = document.createElement("div");
      left.className = "feedback-summary-left";

      const scoreChip = makeScoreChip(payload.score);
      const title = document.createElement("div");
      title.className = "feedback-summary-title";
      title.textContent = payload.score === undefined || payload.score === null
        ? "Coach feedback (click to view)"
        : "Coach feedback (click to view details)";

      left.appendChild(scoreChip);
      left.appendChild(title);

      const chevron = document.createElement("div");
      chevron.className = "feedback-chevron";
      chevron.textContent = "‚ñº";

      summary.appendChild(left);
      summary.appendChild(chevron);

      const body = document.createElement("div");
      body.className = "feedback-body";

      // Answer block
      const ansLabel = document.createElement("div");
      ansLabel.className = "small-label";
      ansLabel.textContent = "Your answer";
      const ansP = document.createElement("p");
      ansP.className = "answer-clamp";
      ansP.textContent = payload.answerText || (payload.hasMediaOnly ? "(Recording only ‚Äî transcript not available.)" : "(No text answer.)");

      body.appendChild(ansLabel);
      body.appendChild(ansP);

      // If no feedback yet
      if (!payload.hasFeedback) {
        const hint = document.createElement("p");
        hint.style.marginTop = "10px";
        hint.style.color = "rgba(15, 23, 42, 0.65)";
        hint.textContent = 'No feedback yet. Type your answer and click "Save answer".';
        body.appendChild(hint);
      } else {
        // Grid callouts
        const grid = document.createElement("div");
        grid.className = "feedback-grid";

        const good = document.createElement("div");
        good.className = "callout good";
        good.innerHTML = `<div class="title">‚úÖ What you did well</div><p>${payload.strengths || "‚Äî"}</p>`;

        const imp = document.createElement("div");
        imp.className = "callout improve";
        imp.innerHTML = `<div class="title">üõ†Ô∏è How you can improve</div><p>${payload.improvements || "‚Äî"}</p>`;

        grid.appendChild(good);
        grid.appendChild(imp);
        body.appendChild(grid);
      }

      details.appendChild(summary);
      details.appendChild(body);
      holder.appendChild(details);
    }

    function createQuestionCard(tag, qIndex, questionText) {
      if (currentQuestionCard) moveCardToHistory(currentQuestionCard);

      const card = document.createElement("div");
      card.className = "practice-question-card practice-question-card-current";
      card.dataset.qIndex = String(qIndex);
      card.dataset.tag = tag || "Question";
      card.dataset.question = questionText || "";

      const header = document.createElement("div");
      header.className = "practice-question-card-header";

      const tagSpan = document.createElement("span");
      tagSpan.className = "question-tag";
      tagSpan.textContent = tag || "Question";

      const idxSpan = document.createElement("span");
      idxSpan.className = "question-counter";
      idxSpan.textContent = "Q" + qIndex;

      header.appendChild(tagSpan);
      header.appendChild(idxSpan);
      card.appendChild(header);

      const qBlock = document.createElement("div");
      qBlock.className = "practice-question-card-section content-width";

      const qLabel = document.createElement("div");
      qLabel.className = "small-label";
      qLabel.textContent = "Question";

      const qP = document.createElement("p");
      qP.textContent = questionText;

      qBlock.appendChild(qLabel);
      qBlock.appendChild(qP);
      card.appendChild(qBlock);

      // divider
      const div = document.createElement("div");
      div.className = "divider";
      card.appendChild(div);

      // Feedback holder (accordion)
      const feedbackHolder = document.createElement("div");
      card._feedbackHolder = feedbackHolder;
      card.appendChild(feedbackHolder);

      // initial state
      renderFeedback(card, {
        hasFeedback: false,
        score: null,
        strengths: "",
        improvements: "",
        answerText: "",
        hasMediaOnly: false
      });

      if (activeQuestionSlot) {
        activeQuestionSlot.innerHTML = "";
        activeQuestionSlot.appendChild(card);
      }

      currentQuestionCard = card;
      return card;
    }

    function moveCardToHistory(card) {
      if (!card || !chatThread) return;

      card.classList.remove("practice-question-card-current");
      card.classList.add("practice-question-card-previous");

      const qIndex = card.dataset.qIndex || "?";
      const tag = card.dataset.tag || "Question";
      const qText = card.dataset.question || "";

      const details = document.createElement("details");
      details.className = "history-item";

      const summary = document.createElement("summary");

      const left = document.createElement("div");
      left.className = "history-summary-left";

      const topRow = document.createElement("div");
      topRow.className = "history-summary-toprow";

      const qChip = document.createElement("span");
      qChip.className = "history-qchip";
      qChip.textContent = "Q" + qIndex;

      const tagChip = document.createElement("span");
      tagChip.className = "history-tag";
      tagChip.textContent = tag;

      topRow.appendChild(qChip);
      topRow.appendChild(tagChip);

      const title = document.createElement("div");
      title.className = "history-summary-title";
      title.textContent = qText;

      left.appendChild(topRow);
      left.appendChild(title);

      const chevron = document.createElement("div");
      chevron.className = "history-chevron";
      chevron.textContent = "‚ñº";

      summary.appendChild(left);
      summary.appendChild(chevron);

      const content = document.createElement("div");
      content.className = "history-content";
      content.appendChild(card);

      details.appendChild(summary);
      details.appendChild(content);

      if (chatThread.firstChild) chatThread.insertBefore(details, chatThread.firstChild);
      else chatThread.appendChild(details);
    }

    // ============================================================
    // Load next question
    // ============================================================
    async function loadNextQuestion() {
      const prevAnswer = (CURRENT_MODE === "project") ? (userAnswerTextarea.value.trim() || null) : null;

      setProgress("status-loading", `Q${QUESTION_COUNT + 1} ¬∑ Loading question‚Ä¶`);
      userAnswerTextarea.value = "";

      sampleBox.classList.add("blurred");
      sampleHintText.textContent = "Hint will appear here after you generate a sample answer.";
      sampleAnswerText.textContent = 'Sample answer will appear here after you click "Generate sample answer".';
      sampleRationaleText.textContent = "The coach's explanation will show here.";
      toggleSampleBtn.textContent = "Hide / Reveal";

      currentMediaBlob = null;
      currentMediaMeta = null;
      if (recordingSummary) recordingSummary.classList.add("hidden");
      recordingPlaybackAudio.classList.add("hidden");
      recordingPlaybackAudio.src = "";
      recordingPlaybackVideo.classList.add("hidden");
      recordingPlaybackVideo.src = "";

      const payload = {
        profile_id: PROFILE_ID,
        mode: CURRENT_MODE,
        behavioral_type:
          CURRENT_MODE === "behavioral" && CURRENT_BEHAVIORAL_TYPE !== "random"
            ? CURRENT_BEHAVIORAL_TYPE
            : (CURRENT_MODE === "behavioral" ? "random" : null),
        entry_key: CURRENT_MODE === "project" ? CURRENT_ENTRY_KEY : null,
        prev_answer: prevAnswer,
      };

      try {
        const resp = await fetch("/api/next_question", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!resp.ok) {
          console.error("next_question failed", resp.status, await resp.text());
          setProgress("status-error", "Failed to load question.");
          return;
        }

        const data = await resp.json();
        CURRENT_QUESTION = data.question || "";
        QUESTION_COUNT += 1;

        CURRENT_BASE_QUESTION = CURRENT_QUESTION;
        CURRENT_THREAD_ID = generateThreadId();
        CURRENT_IS_FOLLOWUP = false;
        FOLLOWUP_DONE = false;
        CURRENT_LAST_ANSWER = "";

        updateFollowupButtonState();

        const tagText = data.tag || "Question";
        currentQuestionCard = createQuestionCard(tagText, QUESTION_COUNT, CURRENT_QUESTION);
        renderBulletHints(data.bullets || []);
        setProgress("status-idle", `Q${QUESTION_COUNT} ¬∑ Ready`);
      } catch (err) {
        console.error(err);
        setProgress("status-error", "Error loading question.");
      }
    }

    // ============================================================
    // Practice history (drawer) & stats  Ôºà‰Ω†ÂéüÊú¨‰øùÁïôÈÇèËºØÔºâ
    // ============================================================
    async function loadPracticeHistory() {
      if (!historyList) return;
      historyList.innerHTML = "<li>Loading...</li>";

      try {
        const resp = await fetch(`/api/practice_history/${PROFILE_ID}`);
        if (!resp.ok) { historyList.innerHTML = "<li>Failed to load history.</li>"; return; }
        const data = await resp.json();
        const turns = data.turns || [];

        if (!turns.length) { historyList.innerHTML = "<li>No history yet.</li>"; return; }
        historyList.innerHTML = "";

        const order = ["project", "auto", "behavioral", "technical", "case", "custom"];
        const grouped = {};
        turns.forEach((t) => {
          const m = t.mode || "auto";
          if (!grouped[m]) grouped[m] = [];
          grouped[m].push(t);
        });

        order.forEach((m) => {
          if (!grouped[m] || !grouped[m].length) return;

          const header = document.createElement("li");
          header.className = "history-item history-item-header";
          header.textContent =
            m === "auto" ? "Auto questions" :
              m === "behavioral" ? "Behavioral questions" :
                m === "project" ? "Project deep dive" :
                  m === "technical" ? "Technical questions" :
                    m === "case" ? "Case reasoning questions" :
                      "Custom questions";
          historyList.appendChild(header);

          grouped[m].slice().reverse().forEach((t) => {
            const li = document.createElement("li");
            li.className = "history-item";

            const title = document.createElement("div");
            title.className = "history-title";
            title.textContent = t.question || "(No question)";

            const meta = document.createElement("div");
            meta.className = "history-meta";
            const ts = t.timestamp ? t.timestamp.slice(0, 19).replace("T", " ") : "";
            const score = (t.score !== undefined && t.score !== null) ? ` ¬∑ Score ${t.score}/10` : "";
            meta.textContent = `${ts}${score}`;

            li.appendChild(title);
            li.appendChild(meta);

            li.addEventListener("click", () => {
              const q = t.question || "";
              const ua = t.user_answer || "(No saved user answer)";
              const sa = t.sample_answer || "(No sample answer)";
              const sc = (t.score !== undefined && t.score !== null) ? `${t.score}/10` : "N/A";

              sampleBox.classList.remove("blurred");
              sampleHintText.textContent = `Question: ${q}`;
              sampleAnswerText.textContent = `Sample answer: ${sa}`;
              sampleRationaleText.textContent = `Your answer: ${ua}  ¬∑  Score: ${sc}`;

              toggleSampleBtn.textContent = "Hide answer";
              setProgress("status-idle", "Viewing past practice");
            });

            historyList.appendChild(li);
          });
        });
      } catch (err) {
        console.error(err);
        historyList.innerHTML = "<li>Error loading history.</li>";
      }
    }

    async function loadPracticeStats() {
      const box = document.getElementById("stats-summary");
      if (!box) return;
      try {
        const resp = await fetch(`/api/practice_stats/${PROFILE_ID}`);
        if (!resp.ok) { box.innerHTML = '<p class="stats-empty">No stats yet.</p>'; return; }
        const data = await resp.json();
        const by = data.by_mode || {};

        const mkStat = (label, val) => `
          <div class="stat-item">
            <span class="stat-val">${val || 0}</span>
            <span class="stat-lbl">${label}</span>
          </div>
        `;

        box.innerHTML = `
          <div class="stats-grid">
             ${mkStat('Total', data.total)}
             ${mkStat('Auto', by.auto)}
             ${mkStat('Behav.', by.behavioral)}
             ${mkStat('Tech', by.technical)}
             ${mkStat('Case', by.case)}
             ${mkStat('Proj.', by.project)}
          </div>
        `;
      } catch (e) {
        box.innerHTML = '<p class="stats-error">Failed to load stats.</p>';
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      loadPracticeStats();
      loadPracticeHistory();
      loadNextQuestion();
    });

    // ============================================================
    // Follow-up question Ôºà‰øùÁïôÔºâ
    // ============================================================
    async function askFollowupQuestion() {
      if (!CURRENT_QUESTION || !CURRENT_BASE_QUESTION) {
        setProgress("status-error", "No active question. Click 'Next question' first.");
        return;
      }
      if (FOLLOWUP_DONE) {
        setProgress("status-idle", "No more follow-up questions for this topic.");
        return;
      }

      const typed = userAnswerTextarea.value.trim();
      const baseAnswer = typed || (CURRENT_LAST_ANSWER ? CURRENT_LAST_ANSWER.trim() : "");
      if (!baseAnswer) {
        setProgress("status-error", "Type your answer before asking a follow-up.");
        updateFollowupButtonState();
        return;
      }

      const selectedBullets = [];
      document.querySelectorAll("#bullet-hints input[type='checkbox']:checked")
        .forEach((cb) => {
          selectedBullets.push({ section: cb.dataset.section, entry: cb.dataset.entry, text: cb.dataset.text });
        });

      const payload = {
        profile_id: PROFILE_ID,
        mode: CURRENT_MODE,
        base_question: CURRENT_BASE_QUESTION,
        user_answer: baseAnswer,
        thread_id: CURRENT_THREAD_ID,
        entry_key: CURRENT_MODE === "project" ? CURRENT_ENTRY_KEY : null,
        bullets: selectedBullets.length ? selectedBullets : null,
      };

      setProgress("status-loading", `Q${QUESTION_COUNT + 1} ¬∑ Loading follow-up‚Ä¶`);

      try {
        const resp = await fetch("/api/followup_question", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!resp.ok) {
          console.error("followup_question failed", resp.status, await resp.text());
          setProgress("status-error", "Failed to load follow-up question.");
          return;
        }

        const data = await resp.json();
        if (data.done || !data.question) {
          FOLLOWUP_DONE = true;
          updateFollowupButtonState();
          setProgress("status-idle", data.message || "No more follow-up questions.");
          return;
        }

        CURRENT_QUESTION = data.question || "";
        QUESTION_COUNT += 1;
        CURRENT_IS_FOLLOWUP = true;
        CURRENT_THREAD_ID = data.thread_id || CURRENT_THREAD_ID;
        CURRENT_LAST_ANSWER = "";

        const tagText = data.tag || "Follow-up";
        currentQuestionCard = createQuestionCard(tagText, QUESTION_COUNT, CURRENT_QUESTION);
        renderBulletHints(data.bullets || []);
        userAnswerTextarea.value = "";

        updateFollowupButtonState();
        setProgress("status-idle", `Q${QUESTION_COUNT} ¬∑ Follow-up ready`);
      } catch (err) {
        console.error(err);
        setProgress("status-error", "Error loading follow-up question.");
      }
    }

    if (followupQuestionBtn) followupQuestionBtn.addEventListener("click", askFollowupQuestion);

    // ============================================================
    // Generate sample answer Ôºà‰øùÁïôÔºâ
    // ============================================================
    async function generateSampleAnswer() {
      if (!CURRENT_QUESTION) { setProgress("status-error", "No question yet."); return; }

      const selectedBullets = [];
      document.querySelectorAll("#bullet-hints input[type='checkbox']:checked")
        .forEach((cb) => {
          selectedBullets.push({ section: cb.dataset.section, entry: cb.dataset.entry, text: cb.dataset.text });
        });

      const userText = userAnswerTextarea.value.trim() || null;

      const payload = {
        profile_id: PROFILE_ID,
        question: CURRENT_QUESTION,
        mode: CURRENT_MODE,
        behavioral_type:
          CURRENT_MODE === "behavioral" && CURRENT_BEHAVIORAL_TYPE !== "random"
            ? CURRENT_BEHAVIORAL_TYPE
            : (CURRENT_MODE === "behavioral" ? "random" : null),
        entry_key: CURRENT_MODE === "project" ? CURRENT_ENTRY_KEY : null,
        user_answer: userText,
        bullets: selectedBullets.length ? selectedBullets : null,
        thread_id: CURRENT_THREAD_ID,
        is_followup: CURRENT_IS_FOLLOWUP,
      };

      setProgress("status-loading", `Q${QUESTION_COUNT} ¬∑ Generating sample answer‚Ä¶`);

      try {
        const resp = await fetch("/api/generate_sample_answer", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!resp.ok) {
          console.error("generate_sample_answer failed", resp.status, await resp.text());
          setProgress("status-error", "Failed to generate sample answer.");
          return;
        }

        const data = await resp.json();
        const answerText = data.answer || "(No answer returned)";
        const hintText = data.hint || "No hint returned.";
        const rationaleText = data.rationale || "No rationale returned.";

        sampleBox.classList.add("blurred");
        sampleHintText.textContent = hintText;
        sampleAnswerText.textContent = answerText;
        sampleRationaleText.textContent = rationaleText;
        toggleSampleBtn.textContent = "Hide / Reveal";

        LAST_SAMPLE_ANSWER = answerText;
        COACH_CHAT_HISTORY = [];
        if (coachChatThread) coachChatThread.innerHTML = "";

        setProgress("status-success", `Q${QUESTION_COUNT} ¬∑ Sample answer ready`);
      } catch (err) {
        console.error(err);
        setProgress("status-error", "Error generating sample answer.");
      }
    }

    if (generateAnswerBtn) generateAnswerBtn.addEventListener("click", generateSampleAnswer);

    if (toggleSampleBtn) {
      toggleSampleBtn.addEventListener("click", () => {
        if (sampleBox.classList.contains("blurred")) {
          sampleBox.classList.remove("blurred");
          toggleSampleBtn.textContent = "Hide answer";
        } else {
          sampleBox.classList.add("blurred");
          toggleSampleBtn.textContent = "Hide / Reveal";
        }
      });
    }

    // ============================================================
    // Mode / buttons
    // ============================================================
    questionModeSelect.addEventListener("change", () => {
      CURRENT_MODE = questionModeSelect.value;

      if (CURRENT_MODE === "behavioral") {
        behavioralTypeWrapper.style.display = "block";
        projectEntryWrapper.style.display = "none";
        customQuestionPanel.style.display = "none";
      } else if (CURRENT_MODE === "project") {
        behavioralTypeWrapper.style.display = "none";
        projectEntryWrapper.style.display = "block";
        customQuestionPanel.style.display = "none";
        loadProjectEntriesOnce();
      } else if (CURRENT_MODE === "custom") {
        behavioralTypeWrapper.style.display = "none";
        projectEntryWrapper.style.display = "none";
        customQuestionPanel.style.display = "block";
      } else {
        behavioralTypeWrapper.style.display = "none";
        projectEntryWrapper.style.display = "none";
        customQuestionPanel.style.display = "none";
      }

      userAnswerTextarea.value = "";
      CURRENT_BASE_QUESTION = "";
      CURRENT_THREAD_ID = null;
      CURRENT_IS_FOLLOWUP = false;
      FOLLOWUP_DONE = false;
      CURRENT_LAST_ANSWER = "";
      updateFollowupButtonState();

      if (CURRENT_MODE !== "custom") loadNextQuestion();
      else setProgress("status-idle", "Custom mode ¬∑ Type your question.");
    });

    behavioralTypeSelect.addEventListener("change", () => {
      CURRENT_BEHAVIORAL_TYPE = behavioralTypeSelect.value;
      if (CURRENT_MODE === "behavioral") {
        QUESTION_COUNT = 0;
        chatThread.innerHTML = "";
        if (activeQuestionSlot) activeQuestionSlot.innerHTML = "";
        currentQuestionCard = null;
        loadNextQuestion();
      }
    });

    projectEntrySelect.addEventListener("change", () => {
      CURRENT_ENTRY_KEY = projectEntrySelect.value || null;
      if (CURRENT_MODE === "project" && CURRENT_ENTRY_KEY) {
        QUESTION_COUNT = 0;
        chatThread.innerHTML = "";
        if (activeQuestionSlot) activeQuestionSlot.innerHTML = "";
        currentQuestionCard = null;
        loadNextQuestion();
      }
    });

    if (nextQuestionBtn) nextQuestionBtn.addEventListener("click", () => loadNextQuestion());

    // Custom question flow
    if (customQuestionBtn) {
      customQuestionBtn.addEventListener("click", async () => {
        if (CURRENT_MODE !== "custom") {
          questionModeSelect.value = "custom";
          questionModeSelect.dispatchEvent(new Event("change"));
        }

        const qText = customQuestionText.value.trim();
        if (!qText) { setProgress("status-error", "Please type your custom question first."); return; }

        CURRENT_QUESTION = qText;
        QUESTION_COUNT += 1;

        CURRENT_BASE_QUESTION = CURRENT_QUESTION;
        CURRENT_THREAD_ID = generateThreadId();
        CURRENT_IS_FOLLOWUP = false;
        FOLLOWUP_DONE = false;
        CURRENT_LAST_ANSWER = "";
        updateFollowupButtonState();

        currentQuestionCard = createQuestionCard("Custom", QUESTION_COUNT, CURRENT_QUESTION);
        userAnswerTextarea.value = "";
        setProgress("status-loading", `Q${QUESTION_COUNT} ¬∑ Fetching suggested bullets‚Ä¶`);

        try {
          const resp = await fetch("/api/retrieve_bullets", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ profile_id: PROFILE_ID, question: CURRENT_QUESTION }),
          });

          if (!resp.ok) {
            console.error("retrieve_bullets failed", resp.status, await resp.text());
            renderBulletHints([]);
            setProgress("status-idle", `Q${QUESTION_COUNT} ¬∑ Custom question ready (no bullets)`);
            return;
          }

          const data = await resp.json();
          renderBulletHints(data.bullets || []);
          setProgress("status-idle", `Q${QUESTION_COUNT} ¬∑ Custom question ready`);
        } catch (err) {
          console.error(err);
          renderBulletHints([]);
          setProgress("status-error", `Q${QUESTION_COUNT} ¬∑ Custom question ready (error loading bullets)`);
        }
      });
    }

    if (historyToggleRow) {
      historyToggleRow.addEventListener("click", () => {
        window.location.href = "{{ request.url_for('practice_history_page', profile_id=profile_id) }}";
      });
    }

    // ============================================================
    // ‚úÖ Save & score answer ‚Äî now renders premium feedback accordion
    // ============================================================
    if (saveAnswerBtn) {
      saveAnswerBtn.addEventListener("click", async () => {
        if (!CURRENT_QUESTION) { setProgress("status-error", "No question to save answer for."); return; }

        const userText = userAnswerTextarea.value.trim();
        const hasText = userText.length > 0;
        const hasMedia = !!currentMediaBlob;

        if (!hasText && !hasMedia) {
          setProgress("status-error", "Type your answer or record audio/video before saving.");
          return;
        }

        if (hasText) CURRENT_LAST_ANSWER = userText;

        const selectedBullets = [];
        document.querySelectorAll("#bullet-hints input[type='checkbox']:checked")
          .forEach((cb) => {
            selectedBullets.push({ section: cb.dataset.section, entry: cb.dataset.entry, text: cb.dataset.text });
          });

        const metaPayload = {
          profile_id: PROFILE_ID,
          question: CURRENT_QUESTION,
          mode: CURRENT_MODE,
          behavioral_type:
            CURRENT_MODE === "behavioral" && CURRENT_BEHAVIORAL_TYPE !== "random"
              ? CURRENT_BEHAVIORAL_TYPE
              : (CURRENT_MODE === "behavioral" ? "random" : null),
          entry_key: CURRENT_MODE === "project" ? CURRENT_ENTRY_KEY : null,
          user_answer: hasText ? userText : null,
          bullets: selectedBullets.length ? selectedBullets : null,
          thread_id: CURRENT_THREAD_ID,
          is_followup: CURRENT_IS_FOLLOWUP,
          sample_answer: LAST_SAMPLE_ANSWER || null,
          media_meta: currentMediaMeta || null,
        };

        const formData = new FormData();
        formData.append("meta", JSON.stringify(metaPayload));
        if (hasMedia) formData.append("media", currentMediaBlob, `answer-${Date.now()}.webm`);

        if (hasMedia && !hasText) setProgress("status-loading", `Q${QUESTION_COUNT} ¬∑ Uploading & transcribing recording‚Ä¶`);
        else if (hasMedia && hasText) setProgress("status-loading", `Q${QUESTION_COUNT} ¬∑ Uploading recording & scoring answer‚Ä¶`);
        else setProgress("status-loading", `Q${QUESTION_COUNT} ¬∑ Saving & scoring answer‚Ä¶`);

        try {
          const resp = await fetch("/api/save_user_answer_with_media", { method: "POST", body: formData });

          if (!resp.ok) {
            console.error("save_user_answer_with_media failed", resp.status, await resp.text());
            setProgress("status-error", "Failed to save answer.");
            return;
          }

          const data = await resp.json();
          const score = data.score;
          const strengths = data.strengths || "";
          const improvements = data.improvements || "";
          const transcript = data.transcript || "";

          let effectiveAnswer = userText;
          if (!effectiveAnswer && transcript) {
            effectiveAnswer = transcript;
            userAnswerTextarea.value = transcript;
            CURRENT_LAST_ANSWER = transcript;
          } else if (effectiveAnswer) {
            CURRENT_LAST_ANSWER = effectiveAnswer;
          }

          if (currentQuestionCard) {
            renderFeedback(currentQuestionCard, {
              hasFeedback: true,
              score,
              strengths,
              improvements,
              answerText: effectiveAnswer,
              hasMediaOnly: !!hasMedia && !effectiveAnswer
            });
            // auto open after save
            const d = currentQuestionCard._feedbackHolder?.querySelector("details");
            if (d) d.open = true;
          }

          if (score !== undefined && score !== null) setProgress("status-success", `Q${QUESTION_COUNT} ¬∑ Saved & scored (${score}/10)`);
          else if (transcript) setProgress("status-success", `Q${QUESTION_COUNT} ¬∑ Transcribed (no score)`);
          else setProgress("status-success", `Q${QUESTION_COUNT} ¬∑ Saved (no score)`);

          updateFollowupButtonState();
          loadPracticeStats();
          loadPracticeHistory();

          currentMediaBlob = null;
          currentMediaMeta = null;
        } catch (err) {
          console.error(err);
          setProgress("status-error", "Error ¬∑ Please try again");
        }
      });
    }

    // ============================================================
    // Recording button bindings
    // ============================================================
    if (openRecorderBtn) openRecorderBtn.addEventListener("click", (e) => { e.preventDefault(); openRecorderModal(); });
    if (recModeAudioBtn) recModeAudioBtn.addEventListener("click", () => setRecMode("audio"));
    if (recModeVideoBtn) recModeVideoBtn.addEventListener("click", () => setRecMode("video"));
    if (recStartBtn) recStartBtn.addEventListener("click", (e) => { e.preventDefault(); startRecording(); });
    if (recStopBtn) recStopBtn.addEventListener("click", (e) => { e.preventDefault(); stopRecording(); });
    if (recCloseBtn) recCloseBtn.addEventListener("click", (e) => { e.preventDefault(); closeRecorderModal(); });
    if (recorderModal) {
      recorderModal.addEventListener("click", (e) => { if (e.target === recorderModal) closeRecorderModal(); });
    }
  </script>
</body>

</html>
