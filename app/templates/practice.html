<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Practice â€“ Intelliview Coach</title>
  <link rel="stylesheet" href="/static/style.css?v=12" />
  <link rel="stylesheet" href="/static/practice.css?v=12" />
  <link rel="stylesheet" href="/static/global-nav.css?v=12" />

  <!-- å°ˆé–€é‡å°ã€Œç•¶å‰é¡Œç›®é«˜äº®ã€èˆŠé¡Œç›®è®Šæ·¡ã€çš„è¦†å¯«æ¨£å¼ -->
  <style>
    /* è®“æ•´å€‹ä¸­é–“å€å¡Šå†é«˜ä¸€é»ï¼Œå•é¡Œçœ‹èµ·ä¾†æ›´æœ‰å­˜åœ¨æ„Ÿ */
    .chat-thread {
      max-height: 460px;
    }

    /* ç•¶å‰é¡Œç›®å¡ç‰‡ï¼šç™½åº•ã€å¾®å¾®è—é‚Šæ¡†ã€å°é™°å½± */
    .practice-question-card-current {
      background: #ffffff;
      border-color: rgba(37, 99, 235, 0.28);
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.10);
    }

    /* èˆŠé¡Œç›®ï¼šç°ç™½åº•ã€æ•´é«”ç¨å¾®æ·¡ä¸€é» */
    .practice-question-card-previous {
      background: #f9fafb;
      opacity: 0.65;
    }

    .practice-question-card-previous .small-label {
      color: #9ca3af;
    }

    .practice-question-card-previous p {
      color: #6b7280;
    }
  </style>
</head>

<body>
  <div class="app-container">
    <!-- Top nav -->
    <header class="top-nav">
      <div class="nav-left">
        <div class="logo-dot"></div>
        <span class="logo-text">Intelliview&nbsp;Coach</span>
      </div>
      <nav class="nav-links">
        <a href="/">Home</a>
        <a href="{{ request.url_for('resume_page') }}">Resume</a>
        <a href="{{ request.url_for('profiles_page') }}">Profiles</a>
        <a href="#" class="nav-active">Mock Interview (Practice)</a>
      </nav>
    </header>

    <main class="practice-page">
      <!-- Top bar with job title and status -->
      <div class="practice-top-bar">
        <div class="top-bar-left">
          <a href="/profiles" class="back-btn" title="Back to Profiles">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" class="back-icon" stroke="currentColor"
              stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M19 12H5M12 19l-7-7 7-7" />
            </svg>
          </a>
          <button class="hamburger-btn" id="hamburger-btn" onclick="toggleDrawer()">
            <span class="hamburger-icon">â˜°</span>
          </button>
          <div class="top-bar-info">
            <h1 class="job-title" id="job-title">{{ job_title }}{% if company %}, {{ company }}{% endif %}</h1>
            <div id="progress-chip-top" class="status-chip status-loading">
              <span class="status-dot"></span>
              <span id="progress-text-top">Q1 Â· Ready</span>
            </div>
          </div>
        </div>
        <div class="top-bar-right">
          <!-- Toggle for AI Helper Column -->
          <label class="toggle-switch">
            <input type="checkbox" id="show-helper-toggle" onchange="toggleHelperColumn()">
            <span class="toggle-slider"></span>
            <span class="toggle-label">Show AI Coach</span>
          </label>
        </div>
      </div>

      <!-- Main Layout Container (Single or Split) -->
      <div class="practice-layout-container" id="practice-layout-container">

        <!-- Left/Center: Main Question & Answer -->
        <section class="practice-main-focused">
          <!-- REMOVED redundant practice-question-header -->

          <!-- Custom question panel -->
          <div id="custom-question-panel" class="custom-question-panel" style="display:none;">
            <div class="small-label">Custom question</div>
            <textarea id="custom-question-text" rows="3" class="textarea"
              placeholder="Type your interview question here, then click 'Use my own question'."></textarea>
          </div>

          <!-- Question cards thread -->
          <div class="chat-thread" id="chat-thread"></div>

          <!-- Answer input area + recording summary / launcher -->
          <div class="practice-answer-block card-section">
            <div class="small-label">Your answer</div>
            <textarea id="user-answer" rows="6" class="textarea"
              placeholder="Type your answer here. You can also record an audio/video answer."></textarea>

            <div class="recording-controls">
              <div class="recording-buttons">
                <button class="btn ghost-btn" id="open-recorder-btn">
                  ğŸ¥ Open recorder
                </button>
              </div>
              <p class="recording-message-small">
                Choose audio or video in the recorder. Your answer will be saved here with this question.
              </p>

              <div id="recording-summary" class="recording-summary hidden">
                <div class="recording-summary-main">
                  <div class="recording-summary-dot"></div>
                  <div id="recording-summary-meta" class="recording-summary-meta">
                    Video Â· 00:00
                  </div>
                </div>
                <audio id="recording-playback-audio" class="recording-playback hidden" controls></audio>
                <video id="recording-playback-video" class="recording-playback hidden" controls playsinline></video>
              </div>
            </div>
          </div>

          <!-- Actions -->
          <div class="practice-main-actions">
            <button class="btn ghost-btn" id="custom-question-btn">
              Use my own question
            </button>
            <button class="btn ghost-btn" id="save-answer-btn">
              Save answer
            </button>
            <button class="btn primary-btn" id="followup-question-btn">
              Ask follow-up
            </button>
            <button class="btn primary-btn" id="next-question-btn">
              Next question
            </button>
          </div>
        </section>

        <!-- Right Column: AI Helper (Hidden by default) -->
        <aside class="practice-helper-column" id="practice-helper-column" style="display: none;">

          <!-- Suggested bullets panel -->
          <div class="helper-card">
            <div class="helper-card-header" onclick="togglePracticeSection('bullets-content')">
              <div class="helper-header-left">
                <span class="helper-icon">ğŸ“</span>
                <span class="helper-title">Suggested Bullets</span>
              </div>
              <span class="helper-toggle-icon">â–¼</span>
            </div>
            <div class="helper-card-content" id="bullets-content">
              <ul id="bullet-hints" class="bullet-hints">
                <li>(Loading...)</li>
              </ul>
            </div>
          </div>

          <!-- AI Sample Answer Section -->
          <div class="helper-card">
            <div class="helper-card-header">
              <div class="helper-header-left">
                <span class="helper-icon">âœ¨</span>
                <span class="helper-title">AI Sample Answer</span>
              </div>
            </div>

            <div class="helper-card-content">
              <div class="helper-actions">
                <button class="btn small-btn ghost-btn" id="generate-answer-btn">Generate</button>
                <button class="btn small-btn ghost-btn" id="toggle-sample-btn">Reveal</button>
              </div>

              <div class="sample-content blurred" id="sample-answer-box">
                <div id="sample-hint-block" class="sample-inner-block">
                  <div class="small-label">Hint</div>
                  <p id="sample-hint-text">Hint will appear here.</p>
                </div>

                <div class="sample-answer-block sample-inner-block">
                  <div class="small-label">Answer</div>
                  <p id="sample-answer-text">Sample answer will appear here.</p>
                </div>

                <div class="sample-rationale-block sample-inner-block">
                  <div class="small-label">Rationale</div>
                  <p id="sample-rationale-text">Why this works...</p>
                </div>
              </div>
              <p class="sample-hint-footer">Generated using resume bullets + JD.</p>
            </div>
          </div>
        </aside>

      </div>

      <!-- Auxiliary Drawer (Hidden by default) -->
      <div class="drawer-overlay" id="drawer-overlay" onclick="closeDrawer()"></div>
      <aside class="auxiliary-drawer" id="auxiliary-drawer">
        <div class="drawer-header">
          <div class="drawer-title-wrapper">
            <!-- Avatar removed as requested -->
            <div class="profile-header-info">
              <div class="profile-role-text">{{ job_title }}</div>
              <div class="profile-id-text">{{ profile_id }}</div>
            </div>
          </div>
          <button class="close-drawer-btn" onclick="closeDrawer()">Ã—</button>
        </div>
        <div class="drawer-content scroll-y">

          <div class="drawer-menu-list">
            <!-- Mode Setting -->
            <div class="drawer-menu-item">
              <div class="menu-item-header">
                <span class="menu-icon">âš™ï¸</span>
                <span class="menu-label">Practice Mode</span>
              </div>
              <div class="menu-control">
                <select id="question-mode" class="clean-select">
                  <option value="auto">Auto (from JD)</option>
                  <option value="behavioral">Behavioral</option>
                  <option value="project">Project deep dive</option>
                  <option value="technical">Technical</option>
                  <option value="case">Case reasoning</option>
                  <option value="custom">Custom question</option>
                </select>
              </div>
            </div>

            <!-- Conditional Sub-settings -->
            <div id="behavioral-type-wrapper" class="drawer-menu-item submenu-item" style="display: none;">
              <div class="menu-control">
                <label class="small-label">Focus Area</label>
                <select id="behavioral-type-select" class="clean-select">
                  <option value="random">Random</option>
                  <option value="teamwork">Teamwork</option>
                  <option value="conflict">Conflict</option>
                  <option value="leadership">Leadership</option>
                  <option value="failure">Failure / mistakes</option>
                  <option value="strengths_weaknesses">Strengths & weaknesses</option>
                </select>
              </div>
            </div>

            <div id="project-entry-wrapper" class="drawer-menu-item submenu-item" style="display: none;">
              <div class="menu-control">
                <label class="small-label">Select Experience</label>
                <select id="project-entry-select" class="clean-select">
                  <option value="">Select an entryâ€¦</option>
                </select>
              </div>
            </div>

            <!-- Stats -->
            <div class="drawer-menu-item">
              <div class="menu-item-header">
                <span class="menu-icon">ğŸ“Š</span>
                <span class="menu-label">Session Stats</span>
              </div>
              <div id="stats-summary" class="menu-content-box">
                <p class="stats-text">Loading...</p>
              </div>
            </div>

            <!-- History -->
            <div class="drawer-menu-item">
              <div class="menu-item-header">
                <span class="menu-icon">ğŸ•’</span>
                <span class="menu-label">History</span>
              </div>
              <div class="menu-actions">
                <a href="{{ request.url_for('practice_history_page', profile_id=profile_id) }}"
                  class="btn small-btn secondary-btn full-width-btn">
                  View Full History
                </a>
              </div>
              <!-- Inline history list could go here if requested, but link is cleaner for "Menu" feel -->
              <div id="history-panel" class="history-preview-list" style="display:none;">
                <ul id="history-list"></ul>
              </div>
              <div class="practice-history-toggle" id="history-toggle"
                style="margin-top:8px; display:flex; justify-content:center;">
                <button class="btn small-btn ghost-btn" id="history-toggle-btn">Show / Hide Recent</button>
              </div>
            </div>
          </div>

        </div>
      </aside>

    </main>
  </div>

  <!-- Coach launcherï¼šå³ä¸‹è§’å°æŒ‰éˆ• -->
  <div class="coach-launcher" id="coach-launcher">
    <button class="coach-launcher-btn">
      <span class="coach-launcher-icon">ğŸ’¬</span>
      <span class="coach-launcher-label">Coach</span>
    </button>
  </div>

  <!-- Coach chat è¦–çª— -->
  <div class="coach-chat-wrapper" id="coach-chat-wrapper" style="display: none;">
    <div class="coach-chat-card">
      <div class="coach-chat-header">
        <span class="coach-chat-title">Coach chat</span>
        <button class="coach-chat-close" id="coach-chat-close">Ã—</button>
      </div>

      <div class="coach-chat-body">
        <div id="coach-chat-thread" class="coach-chat-thread"></div>

        <div class="coach-input-row">
          <textarea id="coach-input" class="coach-input" rows="3"
            placeholder="Tell the coach how you'd like to adjust the answer (e.g., focus on a different project, shorten it, etc.)"></textarea>
          <button class="coach-send-btn" id="coach-send-btn">Send</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Recorder modal -->
  <div class="rec-modal hidden" id="recorder-modal">
    <div class="rec-modal-dialog">
      <div class="rec-modal-header">
        <div>
          <div class="rec-modal-title">Record your answer</div>
          <div class="rec-modal-subtitle">
            Choose audio or video, then click <strong>Start</strong> when you're ready.
          </div>
        </div>
        <button class="rec-close-btn" id="rec-close-btn">Ã—</button>
      </div>

      <div class="rec-current-question" id="rec-current-question"></div>

      <div class="rec-mode-toggle">
        <button id="rec-mode-audio" type="button">Audio only</button>
        <button id="rec-mode-video" type="button" class="active">Video + audio</button>
      </div>

      <div class="rec-preview-shell">
        <video id="rec-preview-video" class="rec-preview-video" autoplay muted playsinline></video>
        <div id="rec-audio-placeholder" class="rec-audio-placeholder hidden">
          Audio-only mode selected. Your microphone will be recorded after you click Start.
        </div>
      </div>

      <div class="rec-bottom-row">
        <div>
          <span class="rec-timer" id="rec-timer">00:00</span>
          <span class="rec-status" id="rec-status"></span>
        </div>
        <div class="rec-actions">
          <button class="btn ghost-btn" id="rec-stop-btn" disabled>Stop</button>
          <button class="btn primary-btn" id="rec-start-btn">Start</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const PROFILE_ID = "{{ profile_id }}";
    const RESUME_ID = "{{ resume_id }}";

    // ---- Global state ----
    let CURRENT_MODE = "auto";
    let CURRENT_BEHAVIORAL_TYPE = "random";
    let CURRENT_ENTRY_KEY = null;
    let CURRENT_QUESTION = "";
    let QUESTION_COUNT = 0;
    let currentQuestionCard = null;    // â† ç›®å‰é«˜äº®çš„é¡Œç›®å¡ç‰‡

    // Follow-up state
    let CURRENT_BASE_QUESTION = "";
    let CURRENT_THREAD_ID = null;
    let CURRENT_IS_FOLLOWUP = false;
    let FOLLOWUP_DONE = false;
    let CURRENT_LAST_ANSWER = "";

    // ---- Recording state (modal) ----
    let REC_MODE = "video"; // "audio" | "video"
    let recMediaStream = null;
    let recMediaRecorder = null;
    let recChunks = [];
    let recStartTime = null;
    let recTimerId = null;
    let lastRecordingUrl = null;
    let lastRecordingType = null;
    let lastRecordingDurationMs = null;

    // ğŸ”¥ å¯¦éš›è¦ä¸Šå‚³çµ¦å¾Œç«¯çš„ Blob + meta
    let currentMediaBlob = null;           // Blob(audio/video)
    let currentMediaMeta = null;           // { type: "audio"|"video", durationMs: ... }

    // dragging
    let isRecDragging = false;
    let recDragStartX = 0;
    let recDragStartY = 0;
    let recDialogStartLeft = 0;
    let recDialogStartTop = 0;

    // ---- DOM refs ----
    const questionModeSelect = document.getElementById("question-mode");
    const behavioralTypeWrapper = document.getElementById("behavioral-type-wrapper");
    const behavioralTypeSelect = document.getElementById("behavioral-type-select");
    const projectEntryWrapper = document.getElementById("project-entry-wrapper");
    const projectEntrySelect = document.getElementById("project-entry-select");
    const customQuestionPanel = document.getElementById("custom-question-panel");
    const customQuestionText = document.getElementById("custom-question-text");
    const customQuestionBtn = document.getElementById("custom-question-btn");

    const questionTagSpan = document.getElementById("question-type-tag");
    const questionIndexSpan = document.getElementById("question-index");
    const chatThread = document.getElementById("chat-thread");
    const userAnswerTextarea = document.getElementById("user-answer");
    const bulletHintsList = document.getElementById("bullet-hints");

    const nextQuestionBtn = document.getElementById("next-question-btn");
    const generateAnswerBtn = document.getElementById("generate-answer-btn");
    const toggleSampleBtn = document.getElementById("toggle-sample-btn");
    const saveAnswerBtn = document.getElementById("save-answer-btn");
    const sampleBox = document.getElementById("sample-answer-box");
    const followupQuestionBtn = document.getElementById("followup-question-btn");

    const historyList = document.getElementById("history-list");
    const historyPanel = document.getElementById("history-panel");
    const historyToggleBtn = document.getElementById("history-toggle-btn");
    const historyToggleRow = document.getElementById("history-toggle");

    const sampleHintText = document.getElementById("sample-hint-text");
    const sampleAnswerText = document.getElementById("sample-answer-text");
    const sampleRationaleText = document.getElementById("sample-rationale-text");

    const coachChatThread = document.getElementById("coach-chat-thread");
    const coachInput = document.getElementById("coach-input");
    const coachSendBtn = document.getElementById("coach-send-btn");
    const coachLauncher = document.getElementById("coach-launcher");
    const coachChatWrapper = document.getElementById("coach-chat-wrapper");
    const coachChatClose = document.getElementById("coach-chat-close");

    const progressChip = document.getElementById("progress-chip");
    const progressText = document.getElementById("progress-text");

    // Recording summary + modal DOM
    const openRecorderBtn = document.getElementById("open-recorder-btn");
    const recordingSummary = document.getElementById("recording-summary");
    const recordingSummaryMeta = document.getElementById("recording-summary-meta");
    const recordingPlaybackAudio = document.getElementById("recording-playback-audio");
    const recordingPlaybackVideo = document.getElementById("recording-playback-video");

    const recorderModal = document.getElementById("recorder-modal");
    const recDialog = recorderModal ? recorderModal.querySelector(".rec-modal-dialog") : null;
    const recModeAudioBtn = document.getElementById("rec-mode-audio");
    const recModeVideoBtn = document.getElementById("rec-mode-video");
    const recPreviewVideo = document.getElementById("rec-preview-video");
    const recAudioPlaceholder = document.getElementById("rec-audio-placeholder");
    const recStartBtn = document.getElementById("rec-start-btn");
    const recStopBtn = document.getElementById("rec-stop-btn");
    const recCloseBtn = document.getElementById("rec-close-btn");
    const recTimerSpan = document.getElementById("rec-timer");
    const recStatusSpan = document.getElementById("rec-status");

    let PROJECT_ENTRIES = [];
    let COACH_CHAT_HISTORY = [];
    let LAST_SAMPLE_ANSWER = "";

    // ---- Status helper ----
    function setProgress(statusClass, text) {
      // 1. Drawer Chip
      const chip1 = document.getElementById("progress-chip");
      const text1 = document.getElementById("progress-text");
      if (chip1) chip1.className = "status-chip " + statusClass;
      if (text1) text1.textContent = text;

      // 2. Top Bar Chip
      const chip2 = document.getElementById("progress-chip-top");
      const text2 = document.getElementById("progress-text-top");
      if (chip2) chip2.className = "status-chip " + statusClass;
      if (text2) text2.textContent = text;
    }

    // ---- Drawer Logic ----
    function toggleDrawer() {
      const drawer = document.getElementById("auxiliary-drawer");
      const overlay = document.getElementById("drawer-overlay");
      if (drawer) drawer.classList.toggle("open");
      if (overlay) overlay.classList.toggle("open");
    }

    function closeDrawer() {
      const drawer = document.getElementById("auxiliary-drawer");
      const overlay = document.getElementById("drawer-overlay");
      if (drawer) drawer.classList.remove("open");
      if (overlay) overlay.classList.remove("open");
    }

    // ---- Helper Column Logic (Allow AI Coach) ----
    function toggleHelperColumn() {
      const checkbox = document.getElementById("show-helper-toggle");
      const layoutContainer = document.getElementById("practice-layout-container");
      const col = document.getElementById("practice-helper-column");

      if (checkbox && checkbox.checked) {
        // Split layout
        if (layoutContainer) layoutContainer.classList.add("split-active");
        if (col) col.style.display = "flex";
      } else {
        // Single layout
        if (layoutContainer) layoutContainer.classList.remove("split-active");
        if (col) col.style.display = "none";
      }
    }

    // Retain legacy togglePracticeSection if needed for internal drawer collapses
    function togglePracticeSection(id) {
      const el = document.getElementById(id);
      if (el) {
        el.style.display = (el.style.display === 'none' || el.style.display === '') ? 'block' : 'none';
      }
    }

    function generateThreadId() {
      return "thread-" + Date.now() + "-" + Math.random().toString(36).slice(2, 8);
    }

    function updateFollowupButtonState() {
      if (!followupQuestionBtn || !userAnswerTextarea) return;
      const typed = userAnswerTextarea.value.trim();
      const hasTyped = typed.length > 0;
      const hasSaved = CURRENT_LAST_ANSWER && CURRENT_LAST_ANSWER.trim().length > 0;

      if (CURRENT_QUESTION && !FOLLOWUP_DONE && (hasTyped || hasSaved)) {
        followupQuestionBtn.disabled = false;
      } else {
        followupQuestionBtn.disabled = true;
      }
    }

    if (followupQuestionBtn) {
      followupQuestionBtn.disabled = true;
    }
    if (userAnswerTextarea && followupQuestionBtn) {
      userAnswerTextarea.addEventListener("input", () => {
        updateFollowupButtonState();
      });
    }

    // Coach launcher open/close
    if (coachLauncher && coachChatWrapper) {
      coachLauncher.addEventListener("click", () => {
        coachChatWrapper.style.display = "block";
      });
    }
    if (coachChatClose && coachChatWrapper) {
      coachChatWrapper.addEventListener("click", () => {
        coachChatWrapper.style.display = "none";
      });
    }

    // ============================================================
    // Recording helpers (modal)
    // ============================================================
    function formatTime(ms) {
      const totalSec = Math.floor(ms / 1000);
      const m = String(Math.floor(totalSec / 60)).padStart(2, "0");
      const s = String(totalSec % 60).padStart(2, "0");
      return `${m}:${s}`;
    }

    function setRecorderStatus(msg, isRecording) {
      if (recStatusSpan) {
        recStatusSpan.textContent = msg || "";
      }
    }

    function resetRecorderState(keepStream) {
      if (recTimerId) {
        clearInterval(recTimerId);
        recTimerId = null;
      }
      recStartTime = null;
      recChunks = [];

      if (recStartBtn) recStartBtn.disabled = false;
      if (recStopBtn) recStopBtn.disabled = true;

      if (recTimerSpan) recTimerSpan.textContent = "00:00";
      if (recStatusSpan) recStatusSpan.textContent = "";

      if (!keepStream && recMediaStream) {
        recMediaStream.getTracks().forEach((t) => t.stop());
        recMediaStream = null;
      }

      if (!keepStream && REC_MODE === "video" && recPreviewVideo) {
        recPreviewVideo.srcObject = null;
      }

      recMediaRecorder = null;
    }

    function centerRecorderDialog() {
      if (!recDialog || recorderModal.classList.contains("hidden")) return;

      recDialog.style.left = "auto";
      recDialog.style.top = "auto";

      const rect = recDialog.getBoundingClientRect();
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      const left = Math.max(16, (vw - rect.width) / 2);
      const top = Math.max(16, (vh - rect.height) / 2);

      recDialog.style.left = left + "px";
      recDialog.style.top = top + "px";
    }

    function setupRecorderDragging() {
      if (!recDialog) return;
      const header = recDialog.querySelector(".rec-modal-header");
      if (!header) return;

      header.style.cursor = "move";

      header.onmousedown = (e) => {
        isRecDragging = true;
        recDialog.classList.add("dragging");
        recDragStartX = e.clientX;
        recDragStartY = e.clientY;

        const rect = recDialog.getBoundingClientRect();
        recDialogStartLeft = rect.left;
        recDialogStartTop = rect.top;

        document.addEventListener("mousemove", onRecDragMove);
        document.addEventListener("mouseup", onRecDragEnd);
      };

      function onRecDragMove(e) {
        if (!isRecDragging) return;
        const dx = e.clientX - recDragStartX;
        const dy = e.clientY - recDragStartY;

        let newLeft = recDialogStartLeft + dx;
        let newTop = recDialogStartTop + dy;

        const margin = 8;
        const maxLeft = window.innerWidth - margin;
        const maxTop = window.innerHeight - margin;

        newLeft = Math.min(Math.max(newLeft, margin - recDialog.offsetWidth), maxLeft);
        newTop = Math.min(Math.max(newTop, margin - recDialog.offsetHeight), maxTop);

        recDialog.style.left = newLeft + "px";
        recDialog.style.top = newTop + "px";
      }

      function onRecDragEnd() {
        if (!isRecDragging) return;
        isRecDragging = false;
        recDialog.classList.remove("dragging");
        document.removeEventListener("mousemove", onRecDragMove);
        document.removeEventListener("mouseup", onRecDragEnd);
      }
    }

    async function ensureVideoPreviewStream() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setRecorderStatus("Your browser does not support recording.", false);
        return;
      }

      try {
        if (!recMediaStream) {
          recMediaStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
            video: { width: 1280, height: 720 },
          });
        }
        if (recPreviewVideo) {
          recPreviewVideo.srcObject = recMediaStream;
        }
        if (recAudioPlaceholder) {
          recAudioPlaceholder.classList.add("hidden");
        }
        if (recPreviewVideo) {
          recPreviewVideo.classList.remove("hidden");
        }
        setRecorderStatus("Camera is on. Click Start when you're ready.", false);
      } catch (err) {
        console.error("ensureVideoPreviewStream error", err);
        setRecorderStatus("Camera / microphone permission denied or unavailable.", false);
      }
    }

    function setRecMode(mode) {
      REC_MODE = mode === "audio" ? "audio" : "video";

      if (REC_MODE === "audio") {
        recModeAudioBtn.classList.add("active");
        recModeVideoBtn.classList.remove("active");

        if (recAudioPlaceholder) recAudioPlaceholder.classList.remove("hidden");
        if (recPreviewVideo) {
          recPreviewVideo.classList.add("hidden");
          recPreviewVideo.srcObject = null;
        }
        if (recMediaStream) {
          recMediaStream.getTracks().forEach((t) => t.stop());
          recMediaStream = null;
        }
        setRecorderStatus("Audio-only mode selected.", false);
      } else {
        recModeAudioBtn.classList.remove("active");
        recModeVideoBtn.classList.add("active");
        if (!recorderModal.classList.contains("hidden")) {
          ensureVideoPreviewStream();
        }
      }

      resetRecorderState(true);
    }

    function openRecorderModal() {
      if (!recorderModal) return;
      recorderModal.classList.remove("hidden");

      const recQ = document.getElementById("rec-current-question");
      if (recQ) {
        recQ.textContent = `Q${QUESTION_COUNT} â€“ ${CURRENT_QUESTION}`;
      }

      setRecMode(REC_MODE);
      centerRecorderDialog();
      setupRecorderDragging();
      window.addEventListener("resize", centerRecorderDialog);

      if (REC_MODE === "video") {
        ensureVideoPreviewStream();
      } else {
        setRecorderStatus("Audio-only mode. Click Start when you're ready.", false);
      }
      resetRecorderState(true);
    }

    function closeRecorderModal() {
      if (!recorderModal) return;

      if (recMediaRecorder && recMediaRecorder.state === "recording") {
        try { recMediaRecorder.stop(); } catch (e) { }
      }
      resetRecorderState(false);
      if (recMediaStream) {
        recMediaStream.getTracks().forEach((t) => t.stop());
        recMediaStream = null;
      }
      if (recPreviewVideo) {
        recPreviewVideo.srcObject = null;
      }
      recorderModal.classList.add("hidden");
      window.removeEventListener("resize", centerRecorderDialog);
    }

    async function startRecording() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setRecorderStatus("Your browser does not support recording.", false);
        return;
      }

      try {
        resetRecorderState(true);
        if (recStartBtn) recStartBtn.disabled = true;
        if (recStopBtn) recStopBtn.disabled = false;

        if (REC_MODE === "audio") {
          if (!recMediaStream) {
            recMediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          }
          if (recPreviewVideo) {
            recPreviewVideo.srcObject = null;
          }
        } else {
          if (!recMediaStream) {
            await ensureVideoPreviewStream();
          }
        }

        const mime = REC_MODE === "audio" ? "audio/webm" : "video/webm";
        recMediaRecorder = new MediaRecorder(recMediaStream, { mimeType: mime });
        const thisRecordingMode = REC_MODE;
        recChunks = [];

        recMediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) recChunks.push(e.data);
        };

        recMediaRecorder.onstop = () => {
          const blob = new Blob(recChunks, { type: mime });

          // å­˜æˆé€™ä¸€é¡Œè¦ä¸Šå‚³çš„ media
          currentMediaBlob = blob;
          currentMediaMeta = {
            type: thisRecordingMode === "audio" ? "audio" : "video",
            durationMs: recStartTime ? (Date.now() - recStartTime) : null,
          };

          if (lastRecordingUrl) {
            URL.revokeObjectURL(lastRecordingUrl);
          }
          lastRecordingUrl = URL.createObjectURL(blob);
          lastRecordingType = thisRecordingMode;
          lastRecordingDurationMs = recStartTime ? Date.now() - recStartTime : null;

          if (recordingSummary) recordingSummary.classList.remove("hidden");
          if (recordingSummaryMeta) {
            const dur = lastRecordingDurationMs ? formatTime(lastRecordingDurationMs) : "";
            recordingSummaryMeta.textContent =
              `${thisRecordingMode === "audio" ? "Audio" : "Video"} Â· ${dur}`;
          }

          if (thisRecordingMode === "audio") {
            recordingPlaybackAudio.classList.remove("hidden");
            recordingPlaybackAudio.src = lastRecordingUrl;
            recordingPlaybackVideo.classList.add("hidden");
            recordingPlaybackVideo.src = "";
          } else {
            recordingPlaybackVideo.classList.remove("hidden");
            recordingPlaybackVideo.src = lastRecordingUrl;
            recordingPlaybackAudio.classList.add("hidden");
            recordingPlaybackAudio.src = "";
          }

          if (recPreviewVideo) {
            recPreviewVideo.srcObject = null;
          }
          if (recMediaStream) {
            recMediaStream.getTracks().forEach((t) => t.stop());
            recMediaStream = null;
          }

          setRecorderStatus("Recording saved.", false);
          if (recStartBtn) recStartBtn.disabled = false;
          if (recStopBtn) recStopBtn.disabled = true;
          if (recTimerId) {
            clearInterval(recTimerId);
            recTimerId = null;
          }
          if (recTimerSpan) recTimerSpan.textContent = "00:00";

          closeRecorderModal();
        };

        recMediaRecorder.start();
        recStartTime = Date.now();
        setRecorderStatus("Recordingâ€¦", true);

        if (recTimerId) clearInterval(recTimerId);
        recTimerId = setInterval(() => {
          if (!recStartTime) return;
          const elapsed = Date.now() - recStartTime;
          if (recTimerSpan) recTimerSpan.textContent = formatTime(elapsed);
        }, 500);
      } catch (err) {
        console.error("startRecording error", err);
        setRecorderStatus("Permission denied or device unavailable.", false);
        if (recStartBtn) recStartBtn.disabled = false;
        if (recStopBtn) recStopBtn.disabled = true;
        if (recMediaStream) {
          recMediaStream.getTracks().forEach((t) => t.stop());
          recMediaStream = null;
        }
      }
    }

    // ğŸ”¥ æŒ‰ Stop æ™‚ç¾åœ¨æœƒç«‹åˆ»çµæŸéŒ„å½±æ¨¡å¼
    function stopRecording() {
      if (!recMediaRecorder || recMediaRecorder.state !== "recording") return;

      recMediaRecorder.stop();
      setRecorderStatus("Finishing recordingâ€¦", false);

      if (recStopBtn) recStopBtn.disabled = true;

      if (recTimerId) {
        clearInterval(recTimerId);
        recTimerId = null;
      }
      if (recTimerSpan) {
        recTimerSpan.textContent = "00:00";
      }

      if (recMediaStream) {
        recMediaStream.getTracks().forEach((t) => t.stop());
        recMediaStream = null;
      }
      if (recPreviewVideo) {
        recPreviewVideo.srcObject = null;
      }
    }

    // ============================================================
    // Suggested bullets
    // ============================================================
    function renderBulletHints(bullets) {
      bulletHintsList.innerHTML = "";

      if (!bullets || !bullets.length) {
        const li = document.createElement("li");
        li.textContent = "No suggested bullets. You can still answer from your experience.";
        bulletHintsList.appendChild(li);
        return;
      }

      const grouped = {};
      bullets.forEach((b) => {
        const entryTitle = b.entry || "General";
        if (!grouped[entryTitle]) grouped[entryTitle] = [];
        grouped[entryTitle].push(b);
      });

      Object.entries(grouped).forEach(([entryTitle, list]) => {
        const li = document.createElement("li");

        const entryHeader = document.createElement("div");
        entryHeader.className = "small-label";
        entryHeader.textContent = entryTitle;
        li.appendChild(entryHeader);

        list.forEach((b) => {
          const row = document.createElement("label");
          row.className = "bullet-hint-row";

          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.dataset.section = b.section || "";
          cb.dataset.entry = b.entry || entryTitle;
          cb.dataset.text = b.text || "";

          const span = document.createElement("span");
          span.textContent = b.text || "";

          row.appendChild(cb);
          row.appendChild(span);
          li.appendChild(row);
        });

        bulletHintsList.appendChild(li);
      });
    }

    // ============================================================
    // Floating coach chat
    // ============================================================
    function appendCoachBubble(role, text) {
      if (!coachChatThread) return;
      const row = document.createElement("div");
      row.className = "chat-row " + (role === "assistant" ? "chat-row-assistant" : "chat-row-user");

      const bubble = document.createElement("div");
      bubble.className = "chat-bubble";

      const p = document.createElement("p");
      p.textContent = text;
      bubble.appendChild(p);

      row.appendChild(bubble);
      coachChatThread.appendChild(row);
      coachChatThread.scrollTop = coachChatThread.scrollHeight;
    }

    async function sendCoachMessage() {
      const msg = coachInput.value.trim();
      if (!msg) return;

      if (!CURRENT_QUESTION) {
        setProgress("status-error", "No active question. Click 'Next question' first.");
        return;
      }

      appendCoachBubble("user", msg);
      COACH_CHAT_HISTORY.push({ role: "user", content: msg });
      coachInput.value = "";

      const selectedBullets = [];
      document
        .querySelectorAll("#bullet-hints input[type='checkbox']:checked")
        .forEach((cb) => {
          selectedBullets.push({
            section: cb.dataset.section,
            entry: cb.dataset.entry,
            text: cb.dataset.text,
          });
        });

      const payload = {
        profile_id: PROFILE_ID,
        resume_id: RESUME_ID,
        mode: CURRENT_MODE,
        question: CURRENT_QUESTION,
        user_message: msg,
        sample_answer: LAST_SAMPLE_ANSWER || null,
        bullets: selectedBullets.length ? selectedBullets : null,
        history: COACH_CHAT_HISTORY,
      };

      setProgress("status-loading", `Q${QUESTION_COUNT} Â· Coach is thinkingâ€¦`);

      try {
        const resp = await fetch("/api/coach_chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!resp.ok) {
          console.error("coach_chat failed", resp.status, await resp.text());
          setProgress("status-error", "Coach chat failed.");
          return;
        }

        const data = await resp.json();
        const reply = data.reply || "(No reply)";

        COACH_CHAT_HISTORY.push({ role: "assistant", content: reply });
        appendCoachBubble("assistant", reply);

        setProgress("status-success", `Q${QUESTION_COUNT} Â· Coach replied`);
      } catch (err) {
        console.error(err);
        setProgress("status-error", "Coach chat error.");
      }
    }

    if (coachSendBtn) {
      coachSendBtn.addEventListener("click", sendCoachMessage);
    }

    // ============================================================
    // Project entries
    // ============================================================
    async function loadProjectEntriesOnce() {
      if (PROJECT_ENTRIES.length > 0) return;
      try {
        const resp = await fetch(`/api/profile_entries/${PROFILE_ID}`);
        if (!resp.ok) {
          console.error("Failed to load profile entries", resp.status);
          return;
        }
        const data = await resp.json();
        PROJECT_ENTRIES = (data.entries || []);

        projectEntrySelect.innerHTML = "";
        const opt0 = document.createElement("option");
        opt0.value = "";
        opt0.textContent = "Select an entryâ€¦";
        projectEntrySelect.appendChild(opt0);

        const MAX_LABEL_LEN = 60;
        PROJECT_ENTRIES.forEach((item) => {
          const opt = document.createElement("option");
          opt.value = item.entry_key;
          let label = item.label || "";
          if (label.length > MAX_LABEL_LEN) {
            opt.textContent = label.slice(0, MAX_LABEL_LEN) + "â€¦";
          } else {
            opt.textContent = label;
          }
          opt.title = label;
          projectEntrySelect.appendChild(opt);
        });
      } catch (err) {
        console.error(err);
      }
    }

    // ============================================================
    // Question card
    // ============================================================
    function createQuestionCard(tag, qIndex, questionText) {
      // å…ˆæŠŠèˆŠçš„ current å¡ç‰‡é™ç´šæˆ previousï¼ˆæ·¡ç°ï¼‰
      if (currentQuestionCard) {
        currentQuestionCard.classList.remove("practice-question-card-current");
        currentQuestionCard.classList.add("practice-question-card-previous");
      }

      const card = document.createElement("div");
      card.className = "practice-question-card practice-question-card-current";

      const header = document.createElement("div");
      header.className = "practice-question-card-header";

      const tagSpan = document.createElement("span");
      tagSpan.className = "question-tag";
      tagSpan.textContent = tag || "Question";

      const idxSpan = document.createElement("span");
      idxSpan.className = "question-counter";
      idxSpan.textContent = "Q" + qIndex;

      header.appendChild(tagSpan);
      header.appendChild(idxSpan);
      card.appendChild(header);

      const qBlock = document.createElement("div");
      qBlock.className = "practice-question-card-section";
      const qLabel = document.createElement("div");
      qLabel.className = "small-label";
      qLabel.textContent = "Question";
      const qP = document.createElement("p");
      qP.textContent = questionText;
      qBlock.appendChild(qLabel);
      qBlock.appendChild(qP);
      card.appendChild(qBlock);

      const feedbackBlock = document.createElement("div");
      feedbackBlock.className = "practice-question-card-section";
      feedbackBlock.innerHTML = `
        <div class="small-label">Coach feedback</div>
        <p class="feedback-placeholder">
          No feedback yet. Type your answer and click "Save answer".
        </p>
      `;
      card.appendChild(feedbackBlock);

      card._feedbackBlock = feedbackBlock;

      // âœ… æœ€æ–°é¡Œç›®æ’åœ¨æœ€ä¸Šé¢ï¼Œè€Œä¸æ˜¯æœ€ä¸‹é¢
      if (chatThread.firstChild) {
        chatThread.insertBefore(card, chatThread.firstChild);
      } else {
        chatThread.appendChild(card);
      }
      chatThread.scrollTop = 0;

      // æ›´æ–°ç›®å‰é«˜äº®å¡ç‰‡æŒ‡æ¨™
      currentQuestionCard = card;

      return card;
    }

    // ============================================================
    // Load next question
    // ============================================================
    async function loadNextQuestion() {
      const prevAnswer =
        CURRENT_MODE === "project"
          ? (userAnswerTextarea.value.trim() || null)
          : null;

      setProgress("status-loading", `Q${QUESTION_COUNT + 1} Â· Loading questionâ€¦`);
      userAnswerTextarea.value = "";

      sampleBox.classList.add("blurred");
      sampleHintText.textContent =
        "Hint will appear here after you generate a sample answer.";
      sampleAnswerText.textContent =
        'Sample answer will appear here after you click "Generate sample answer".';
      sampleRationaleText.textContent =
        "The coach's explanation will show here.";
      toggleSampleBtn.textContent = "Hide / Reveal";

      // æ›é¡Œæ™‚æŠŠä¸Šä¸€é¡ŒéŒ„éŸ³æ¸…æ‰
      currentMediaBlob = null;
      currentMediaMeta = null;
      if (recordingSummary) recordingSummary.classList.add("hidden");
      recordingPlaybackAudio.classList.add("hidden");
      recordingPlaybackAudio.src = "";
      recordingPlaybackVideo.classList.add("hidden");
      recordingPlaybackVideo.src = "";

      const payload = {
        profile_id: PROFILE_ID,
        resume_id: RESUME_ID,
        mode: CURRENT_MODE,
        behavioral_type:
          CURRENT_MODE === "behavioral" && CURRENT_BEHAVIORAL_TYPE !== "random"
            ? CURRENT_BEHAVIORAL_TYPE
            : (CURRENT_MODE === "behavioral" ? "random" : null),
        entry_key: CURRENT_MODE === "project" ? CURRENT_ENTRY_KEY : null,
        prev_answer: prevAnswer,
      };

      try {
        const resp = await fetch("/api/next_question", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!resp.ok) {
          console.error("next_question failed", resp.status, await resp.text());
          setProgress("status-error", "Failed to load question.");
          return;
        }

        const data = await resp.json();
        CURRENT_QUESTION = data.question || "";
        QUESTION_COUNT += 1;

        CURRENT_BASE_QUESTION = CURRENT_QUESTION;
        CURRENT_THREAD_ID = generateThreadId();
        CURRENT_IS_FOLLOWUP = false;
        FOLLOWUP_DONE = false;
        CURRENT_LAST_ANSWER = "";

        updateFollowupButtonState();

        const tagText = data.tag || "Question";
        if (questionTagSpan) questionTagSpan.textContent = tagText;
        if (questionIndexSpan) questionIndexSpan.textContent = "Q" + QUESTION_COUNT;

        currentQuestionCard = createQuestionCard(tagText, QUESTION_COUNT, CURRENT_QUESTION);
        renderBulletHints(data.bullets || []);
        setProgress("status-idle", `Q${QUESTION_COUNT} Â· Ready`);
      } catch (err) {
        console.error(err);
        setProgress("status-error", "Error loading question.");
      }
    }

    // ============================================================
    // Practice historyï¼ˆä¿ç•™åŸå‡½å¼ï¼Œä½† panel ä¸å†æœƒè¢«æ‰“é–‹ï¼‰
    // ============================================================
    async function loadPracticeHistory() {
      if (!historyList) return;
      historyList.innerHTML = "<li>Loading...</li>";

      try {
        const resp = await fetch(`/api/practice_history/${PROFILE_ID}`);
        if (!resp.ok) {
          historyList.innerHTML = "<li>Failed to load history.</li>";
          return;
        }
        const data = await resp.json();
        const turns = data.turns || [];

        if (!turns.length) {
          historyList.innerHTML = "<li>No history yet.</li>";
          return;
        }

        historyList.innerHTML = "";

        const order = ["project", "auto", "behavioral", "technical", "case", "custom"];
        const grouped = {};
        turns.forEach((t) => {
          const m = t.mode || "auto";
          if (!grouped[m]) grouped[m] = [];
          grouped[m].push(t);
        });

        order.forEach((m) => {
          if (!grouped[m] || !grouped[m].length) return;

          const header = document.createElement("li");
          header.className = "history-item history-item-header";
          header.textContent =
            m === "auto" ? "Auto questions" :
              m === "behavioral" ? "Behavioral questions" :
                m === "project" ? "Project deep dive" :
                  m === "technical" ? "Technical questions" :
                    m === "case" ? "Case reasoning questions" :
                      "Custom questions";
          historyList.appendChild(header);

          grouped[m]
            .slice()
            .reverse()
            .forEach((t) => {
              const li = document.createElement("li");
              li.className = "history-item";

              const title = document.createElement("div");
              title.className = "history-title";
              title.textContent = t.question || "(No question)";

              const meta = document.createElement("div");
              meta.className = "history-meta";
              const ts = t.timestamp ? t.timestamp.slice(0, 19).replace("T", " ") : "";
              const score = (t.score !== undefined && t.score !== null)
                ? ` Â· Score ${t.score}/10`
                : "";
              meta.textContent = `${ts}${score}`;

              li.appendChild(title);
              li.appendChild(meta);

              li.addEventListener("click", () => {
                const q = t.question || "";
                const ua = t.user_answer || "(No saved user answer)";
                const sa = t.sample_answer || "(No sample answer)";
                const sc = (t.score !== undefined && t.score !== null)
                  ? `${t.score}/10`
                  : "N/A";

                sampleBox.classList.remove("blurred");
                sampleHintText.textContent = `Question: ${q}`;
                sampleAnswerText.textContent = `Sample answer: ${sa}`;
                sampleRationaleText.textContent =
                  `Your answer: ${ua}  Â·  Score: ${sc}`;

                toggleSampleBtn.textContent = "Hide answer";
                setProgress("status-idle", "Viewing past practice");
              });

              historyList.appendChild(li);
            });
        });
      } catch (err) {
        console.error(err);
        historyList.innerHTML = "<li>Error loading history.</li>";
      }
    }

    // ============================================================
    // Stats
    // ============================================================
    async function loadPracticeStats() {
      const box = document.getElementById("stats-summary");
      if (!box) return;
      try {
        const resp = await fetch(`/api/practice_stats/${PROFILE_ID}`);
        if (!resp.ok) {
          box.innerHTML = '<p class="stats-empty">No stats yet.</p>';
          return;
        }
        const data = await resp.json();
        const by = data.by_mode || {};

        // Helper to create valid stat item
        const mkStat = (label, val, icon) => `
          <div class="stat-item">
            <span class="stat-val">${val || 0}</span>
            <span class="stat-lbl">${label}</span>
          </div>
        `;

        box.innerHTML = `
          <div class="stats-grid">
             ${mkStat('Total', data.total)}
             ${mkStat('Auto', by.auto)}
             ${mkStat('Behav.', by.behavioral)}
             ${mkStat('Tech', by.technical)}
             ${mkStat('Case', by.case)}
             ${mkStat('Proj.', by.project)}
          </div>
        `;

      } catch (e) {
        box.innerHTML = '<p class="stats-error">Failed to load stats.</p>';
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      loadPracticeStats();
      loadPracticeHistory();
      loadNextQuestion();
    });

    // ============================================================
    // Follow-up question
    // ============================================================
    async function askFollowupQuestion() {
      if (!CURRENT_QUESTION || !CURRENT_BASE_QUESTION) {
        setProgress("status-error", "No active question. Click 'Next question' first.");
        return;
      }
      if (FOLLOWUP_DONE) {
        setProgress("status-idle", "No more follow-up questions for this topic.");
        return;
      }

      const typed = userAnswerTextarea.value.trim();
      const baseAnswer = typed || (CURRENT_LAST_ANSWER ? CURRENT_LAST_ANSWER.trim() : "");

      if (!baseAnswer) {
        setProgress("status-error", "Type your answer before asking a follow-up.");
        updateFollowupButtonState();
        return;
      }

      const selectedBullets = [];
      document
        .querySelectorAll("#bullet-hints input[type='checkbox']:checked")
        .forEach((cb) => {
          selectedBullets.push({
            section: cb.dataset.section,
            entry: cb.dataset.entry,
            text: cb.dataset.text,
          });
        });

      const payload = {
        profile_id: PROFILE_ID,
        resume_id: RESUME_ID,
        mode: CURRENT_MODE,
        base_question: CURRENT_BASE_QUESTION,
        user_answer: baseAnswer,
        thread_id: CURRENT_THREAD_ID,
        entry_key: CURRENT_MODE === "project" ? CURRENT_ENTRY_KEY : null,
        bullets: selectedBullets.length ? selectedBullets : null,
      };

      setProgress("status-loading", `Q${QUESTION_COUNT + 1} Â· Loading follow-upâ€¦`);

      try {
        const resp = await fetch("/api/followup_question", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!resp.ok) {
          console.error("followup_question failed", resp.status, await resp.text());
          setProgress("status-error", "Failed to load follow-up question.");
          return;
        }

        const data = await resp.json();

        if (data.done || !data.question) {
          FOLLOWUP_DONE = true;
          updateFollowupButtonState();
          setProgress("status-idle", data.message || "No more follow-up questions.");
          return;
        }

        CURRENT_QUESTION = data.question || "";
        QUESTION_COUNT += 1;
        CURRENT_IS_FOLLOWUP = true;
        CURRENT_THREAD_ID = data.thread_id || CURRENT_THREAD_ID;

        CURRENT_LAST_ANSWER = "";

        const tagText = data.tag || "Follow-up";
        if (questionTagSpan) questionTagSpan.textContent = tagText;
        if (questionIndexSpan) questionIndexSpan.textContent = "Q" + QUESTION_COUNT;

        currentQuestionCard = createQuestionCard(tagText, QUESTION_COUNT, CURRENT_QUESTION);
        renderBulletHints(data.bullets || []);
        userAnswerTextarea.value = "";

        updateFollowupButtonState();
        setProgress("status-idle", `Q${QUESTION_COUNT} Â· Follow-up ready`);
      } catch (err) {
        console.error(err);
        setProgress("status-error", "Error loading follow-up question.");
      }
    }

    if (followupQuestionBtn) {
      followupQuestionBtn.addEventListener("click", askFollowupQuestion);
    }

    // ============================================================
    // Generate sample answer
    // ============================================================
    async function generateSampleAnswer() {
      if (!CURRENT_QUESTION) {
        setProgress("status-error", "No question yet.");
        return;
      }

      const selectedBullets = [];
      document
        .querySelectorAll("#bullet-hints input[type='checkbox']:checked")
        .forEach((cb) => {
          selectedBullets.push({
            section: cb.dataset.section,
            entry: cb.dataset.entry,
            text: cb.dataset.text,
          });
        });

      const userText = userAnswerTextarea.value.trim() || null;

      const payload = {
        profile_id: PROFILE_ID,
        resume_id: RESUME_ID,
        question: CURRENT_QUESTION,
        mode: CURRENT_MODE,
        behavioral_type:
          CURRENT_MODE === "behavioral" && CURRENT_BEHAVIORAL_TYPE !== "random"
            ? CURRENT_BEHAVIORAL_TYPE
            : (CURRENT_MODE === "behavioral" ? "random" : null),
        entry_key: CURRENT_MODE === "project" ? CURRENT_ENTRY_KEY : null,
        user_answer: userText,
        bullets: selectedBullets.length ? selectedBullets : null,
        thread_id: CURRENT_THREAD_ID,
        is_followup: CURRENT_IS_FOLLOWUP,
      };

      setProgress("status-loading", `Q${QUESTION_COUNT} Â· Generating sample answerâ€¦`);

      try {
        const resp = await fetch("/api/generate_sample_answer", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!resp.ok) {
          console.error("generate_sample_answer failed", resp.status, await resp.text());
          setProgress("status-error", "Failed to generate sample answer.");
          return;
        }

        const data = await resp.json();
        const answerText = data.answer || "(No answer returned)";
        const hintText = data.hint || "No hint returned.";
        const rationaleText = data.rationale || "No rationale returned.";

        sampleBox.classList.add("blurred");
        sampleHintText.textContent = hintText;
        sampleAnswerText.textContent = answerText;
        sampleRationaleText.textContent = rationaleText;
        toggleSampleBtn.textContent = "Hide / Reveal";

        LAST_SAMPLE_ANSWER = answerText;
        COACH_CHAT_HISTORY = [];
        coachChatThread.innerHTML = "";

        setProgress("status-success", `Q${QUESTION_COUNT} Â· Sample answer ready`);
      } catch (err) {
        console.error(err);
        setProgress("status-error", "Error generating sample answer.");
      }
    }

    // ============================================================
    // Mode / buttons
    // ============================================================
    questionModeSelect.addEventListener("change", () => {
      CURRENT_MODE = questionModeSelect.value;

      if (CURRENT_MODE === "behavioral") {
        behavioralTypeWrapper.style.display = "block";
        projectEntryWrapper.style.display = "none";
        customQuestionPanel.style.display = "none";
      } else if (CURRENT_MODE === "project") {
        behavioralTypeWrapper.style.display = "none";
        projectEntryWrapper.style.display = "block";
        customQuestionPanel.style.display = "none";
        loadProjectEntriesOnce();
      } else if (CURRENT_MODE === "custom") {
        behavioralTypeWrapper.style.display = "none";
        projectEntryWrapper.style.display = "none";
        customQuestionPanel.style.display = "block";
      } else {
        // auto / technical / case
        behavioralTypeWrapper.style.display = "none";
        projectEntryWrapper.style.display = "none";
        customQuestionPanel.style.display = "none";
      }

      userAnswerTextarea.value = "";

      CURRENT_BASE_QUESTION = "";
      CURRENT_THREAD_ID = null;
      CURRENT_IS_FOLLOWUP = false;
      FOLLOWUP_DONE = false;
      CURRENT_LAST_ANSWER = "";

      updateFollowupButtonState();

      if (CURRENT_MODE !== "custom") {
        loadNextQuestion();
      } else {
        setProgress("status-idle",
          "Custom mode Â· Type your question."
        );
      }
    });

    behavioralTypeSelect.addEventListener("change", () => {
      CURRENT_BEHAVIORAL_TYPE = behavioralTypeSelect.value;
      if (CURRENT_MODE === "behavioral") {
        QUESTION_COUNT = 0;
        chatThread.innerHTML = "";
        currentQuestionCard = null;
        loadNextQuestion();
      }
    });

    projectEntrySelect.addEventListener("change", () => {
      CURRENT_ENTRY_KEY = projectEntrySelect.value || null;
      if (CURRENT_MODE === "project" && CURRENT_ENTRY_KEY) {
        QUESTION_COUNT = 0;
        chatThread.innerHTML = "";
        currentQuestionCard = null;
        loadNextQuestion();
      }
    });

    nextQuestionBtn.addEventListener("click", () => {
      loadNextQuestion();
    });

    generateAnswerBtn.addEventListener("click", () => {
      generateSampleAnswer();
    });

    toggleSampleBtn.addEventListener("click", () => {
      if (sampleBox.classList.contains("blurred")) {
        sampleBox.classList.remove("blurred");
        toggleSampleBtn.textContent = "Hide answer";
      } else {
        sampleBox.classList.add("blurred");
        toggleSampleBtn.textContent = "Hide / Reveal";
      }
    });

    // Custom question flow
    customQuestionBtn.addEventListener("click", async () => {
      if (CURRENT_MODE !== "custom") {
        questionModeSelect.value = "custom";
        questionModeSelect.dispatchEvent(new Event("change"));
      }

      const qText = customQuestionText.value.trim();
      if (!qText) {
        setProgress("status-error", "Please type your custom question first.");
        return;
      }

      CURRENT_QUESTION = qText;
      QUESTION_COUNT += 1;

      CURRENT_BASE_QUESTION = CURRENT_QUESTION;
      CURRENT_THREAD_ID = generateThreadId();
      CURRENT_IS_FOLLOWUP = false;
      FOLLOWUP_DONE = false;
      CURRENT_LAST_ANSWER = "";

      updateFollowupButtonState();

      questionTagSpan.textContent = "Custom";
      questionIndexSpan.textContent = "Q" + QUESTION_COUNT;

      currentQuestionCard = createQuestionCard("Custom", QUESTION_COUNT, CURRENT_QUESTION);
      userAnswerTextarea.value = "";
      setProgress("status-loading", `Q${QUESTION_COUNT} Â· Fetching suggested bulletsâ€¦`);

      try {
        const resp = await fetch("/api/retrieve_bullets", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            profile_id: PROFILE_ID,
            resume_id: RESUME_ID,
            question: CURRENT_QUESTION,
          }),
        });

        if (!resp.ok) {
          console.error("retrieve_bullets failed", resp.status, await resp.text());
          renderBulletHints([]);
          setProgress("status-idle",
            `Q${QUESTION_COUNT} Â· Custom question ready (no bullets)`
          );
          return;
        }

        const data = await resp.json();
        renderBulletHints(data.bullets || []);
        setProgress("status-idle", `Q${QUESTION_COUNT} Â· Custom question ready`);
      } catch (err) {
        console.error(err);
        renderBulletHints([]);
        setProgress("status-error",
          `Q${QUESTION_COUNT} Â· Custom question ready (error loading bullets)`
        );
      }
    });

    // History é»æ“Šæ•´æ’ â†’ ç›´æ¥å°åˆ° history é 
    if (historyToggleRow) {
      historyToggleRow.addEventListener("click", () => {
        window.location.href = "{{ request.url_for('practice_history_page', profile_id=profile_id) }}";
      });
    }

    // ============================================================
    // Save & score answer
    // ============================================================
    if (saveAnswerBtn) {
      saveAnswerBtn.addEventListener("click", async () => {
        if (!CURRENT_QUESTION) {
          setProgress("status-error", "No question to save answer for.");
          return;
        }

        const userText = userAnswerTextarea.value.trim();
        const hasText = userText.length > 0;
        const hasMedia = !!currentMediaBlob;

        if (!hasText && !hasMedia) {
          setProgress("status-error", "Type your answer or record audio/video before saving.");
          return;
        }

        if (hasText) {
          CURRENT_LAST_ANSWER = userText;
        }

        const selectedBullets = [];
        document
          .querySelectorAll("#bullet-hints input[type='checkbox']:checked")
          .forEach((cb) => {
            selectedBullets.push({
              section: cb.dataset.section,
              entry: cb.dataset.entry,
              text: cb.dataset.text,
            });
          });

        const metaPayload = {
          profile_id: PROFILE_ID,
          resume_id: RESUME_ID,
          question: CURRENT_QUESTION,
          mode: CURRENT_MODE,
          behavioral_type:
            CURRENT_MODE === "behavioral" && CURRENT_BEHAVIORAL_TYPE !== "random"
              ? CURRENT_BEHAVIORAL_TYPE
              : (CURRENT_MODE === "behavioral" ? "random" : null),
          entry_key: CURRENT_MODE === "project" ? CURRENT_ENTRY_KEY : null,
          user_answer: hasText ? userText : null,
          bullets: selectedBullets.length ? selectedBullets : null,
          thread_id: CURRENT_THREAD_ID,
          is_followup: CURRENT_IS_FOLLOWUP,
          sample_answer: LAST_SAMPLE_ANSWER || null,
          media_meta: currentMediaMeta || null,
        };

        const formData = new FormData();
        formData.append("meta", JSON.stringify(metaPayload));
        if (hasMedia) {
          formData.append(
            "media",
            currentMediaBlob,
            `answer-${Date.now()}.webm`
          );
        }

        if (hasMedia && !hasText) {
          setProgress(
            "status-loading",
            `Q${QUESTION_COUNT} Â· Uploading & transcribing recordingâ€¦`
          );
        } else if (hasMedia && hasText) {
          setProgress(
            "status-loading",
            `Q${QUESTION_COUNT} Â· Uploading recording & scoring answerâ€¦`
          );
        } else {
          setProgress(
            "status-loading",
            `Q${QUESTION_COUNT} Â· Saving & scoring answerâ€¦`
          );
        }

        try {
          const resp = await fetch("/api/save_user_answer_with_media", {
            method: "POST",
            body: formData,
          });

          if (!resp.ok) {
            console.error("save_user_answer_with_media failed", resp.status, await resp.text());
            setProgress("status-error", "Failed to save answer.");
            return;
          }

          const data = await resp.json();
          const score = data.score;
          const strengths = data.strengths || "";
          const improvements = data.improvements || "";

          const transcript = data.transcript || "";
          let effectiveAnswer = userText;

          if (!effectiveAnswer && transcript) {
            effectiveAnswer = transcript;
            userAnswerTextarea.value = transcript;
            CURRENT_LAST_ANSWER = transcript;
          } else if (effectiveAnswer) {
            CURRENT_LAST_ANSWER = effectiveAnswer;
          }

          if (currentQuestionCard && currentQuestionCard._feedbackBlock) {
            const block = currentQuestionCard._feedbackBlock;
            block.innerHTML = "";

            const yourLabel = document.createElement("div");
            yourLabel.className = "small-label";
            yourLabel.textContent = "Your answer";

            const yourP = document.createElement("p");
            if (effectiveAnswer) {
              yourP.textContent = effectiveAnswer;
            } else if (hasMedia) {
              yourP.textContent = "(Recording only â€” transcript not available.)";
            } else {
              yourP.textContent = "(No text answer.)";
            }

            const coachLabel = document.createElement("div");
            coachLabel.className = "small-label";
            coachLabel.textContent = "Coach feedback";

            const scoreP = document.createElement("p");
            if (score !== undefined && score !== null) {
              scoreP.innerHTML = `I'd rate this answer <strong>${score}/10.</strong>`;
            } else if (effectiveAnswer) {
              scoreP.textContent = "No score yet.";
            } else {
              scoreP.textContent = "No score yet (no text answer).";
            }

            block.appendChild(yourLabel);
            block.appendChild(yourP);
            block.appendChild(coachLabel);
            block.appendChild(scoreP);

            if (strengths) {
              const sLabel = document.createElement("p");
              sLabel.innerHTML = "<strong>What you did well:</strong>";
              const sText = document.createElement("p");
              sText.textContent = strengths;
              block.appendChild(sLabel);
              block.appendChild(sText);
            }

            if (improvements) {
              const iLabel = document.createElement("p");
              iLabel.innerHTML = "<strong>How you can improve:</strong>";
              const iText = document.createElement("p");
              iText.textContent = improvements;
              block.appendChild(iLabel);
              block.appendChild(iText);
            }
          }

          if (score !== undefined && score !== null) {
            if (transcript && !userText) {
              setProgress(
                "status-success",
                `Q${QUESTION_COUNT} Â· Transcribed & scored (${score}/10)`
              );
            } else {
              setProgress(
                "status-success",
                `Q${QUESTION_COUNT} Â· Answer saved & scored (${score}/10)`
              );
            }
          } else if (transcript) {
            setProgress(
              "status-success",
              `Q${QUESTION_COUNT} Â· Recording transcribed (no score)`
            );
          } else {
            setProgress(
              "status-success",
              `Q${QUESTION_COUNT} Â· Recording saved (no text score yet)`
            );
          }

          updateFollowupButtonState();
          loadPracticeStats();
          loadPracticeHistory();

          currentMediaBlob = null;
          currentMediaMeta = null;
        } catch (err) {
          console.error(err);
          setProgress("status-error", "Error Â· Please try again");
        }
      });
    }

    // ============================================================
    // Recording button bindings
    // ============================================================
    if (openRecorderBtn) {
      openRecorderBtn.addEventListener("click", (e) => {
        e.preventDefault();
        openRecorderModal();
      });
    }
    if (recModeAudioBtn) {
      recModeAudioBtn.addEventListener("click", () => setRecMode("audio"));
    }
    if (recModeVideoBtn) {
      recModeVideoBtn.addEventListener("click", () => setRecMode("video"));
    }
    if (recStartBtn) {
      recStartBtn.addEventListener("click", (e) => {
        e.preventDefault();
        startRecording();
      });
    }
    if (recStopBtn) {
      recStopBtn.addEventListener("click", (e) => {
        e.preventDefault();
        stopRecording();
      });
    }
    if (recCloseBtn) {
      recCloseBtn.addEventListener("click", (e) => {
        e.preventDefault();
        closeRecorderModal();
      });
    }
    if (recorderModal) {
      recorderModal.addEventListener("click", (e) => {
        if (e.target === recorderModal) {
          closeRecorderModal();
        }
      });
    }

    // ============================================================
    // Collapsible section toggle function
    // ============================================================
    function togglePracticeSection(sectionId) {
      const content = document.getElementById(sectionId);
      const toggle = content.previousElementSibling;

      if (content.classList.contains('active')) {
        content.classList.remove('active');
        toggle.classList.remove('active');
      } else {
        content.classList.add('active');
        toggle.classList.add('active');
      }
    }
  </script>
</body>

</html>